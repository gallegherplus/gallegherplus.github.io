<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="screen-orientation" content="landscape">
    <title>R√≠o Salvaje - Carreras en el Litoral Argentino</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #title {
            color: #ffd700;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px #000, 0 0 10px rgba(255,215,0,0.5);
            margin-bottom: 6px;
        }
        
        #subtitle {
            color: #00bcd4;
            font-size: 11px;
            margin-bottom: 8px;
            text-shadow: 1px 1px #000;
        }
        
        canvas { 
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,150,200,0.4), inset 0 0 20px rgba(0,0,0,0.3);
        }
        
        #controls {
            display: flex;
            gap: 15px;
            margin-top: 12px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .control-label {
            color: #aaa;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-row {
            display: flex;
            gap: 5px;
        }
        
        .dpad-container {
            display: grid;
            grid-template-columns: 45px 45px 45px;
            grid-template-rows: 45px 45px;
            gap: 3px;
        }
        
        .game-btn {
            width: 55px;
            height: 50px;
            background: linear-gradient(145deg, #2a2a4a, #1a1a2a);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: all 0.1s;
            text-shadow: 0 0 5px currentColor;
        }
        
        .game-btn:hover {
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            border-color: #6a6aaa;
        }
        
        .game-btn:active, .game-btn.pressed {
            background: linear-gradient(145deg, #5a5a9a, #4a4a7a);
            border-color: #8a8aca;
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(100,100,200,0.5);
        }
        
        .game-btn.accel {
            background: linear-gradient(145deg, #2a4a2a, #1a3a1a);
            border-color: #4a8a4a;
            color: #4f4;
        }
        .game-btn.accel:active, .game-btn.accel.pressed {
            background: linear-gradient(145deg, #4a8a4a, #3a6a3a);
            box-shadow: 0 0 15px rgba(100,200,100,0.5);
        }
        
        .game-btn.jump {
            background: linear-gradient(145deg, #4a4a2a, #3a3a1a);
            border-color: #8a8a4a;
            color: #ff0;
        }
        .game-btn.jump:active, .game-btn.jump.pressed {
            background: linear-gradient(145deg, #7a7a4a, #5a5a3a);
            box-shadow: 0 0 15px rgba(200,200,100,0.5);
        }
        
        .game-btn.start {
            background: linear-gradient(145deg, #4a2a2a, #3a1a1a);
            border-color: #8a4a4a;
            color: #f66;
        }
        .game-btn.start:active, .game-btn.start.pressed {
            background: linear-gradient(145deg, #8a4a4a, #6a3a3a);
            box-shadow: 0 0 15px rgba(200,100,100,0.5);
        }
        
        .game-btn.dpad {
            width: 45px;
            height: 45px;
            font-size: 16px;
        }
        
        .dpad-spacer {
            width: 45px;
            height: 45px;
        }
        
        #instructions {
            color: #888;
            font-size: 10px;
            margin-top: 8px;
            text-align: center;
            max-width: 600px;
        }
        
        .key-hint {
            color: #ffd700;
            font-weight: bold;
        }
        
        #gamepadStatus {
            color: #0f0;
            font-size: 10px;
            margin-top: 5px;
            text-align: center;
        }
        
        #mobileIndicator {
            color: #ff0;
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
            display: none;
        }
        
        .mobile-mode #controls {
            display: none;
        }
        
        .mobile-mode #instructions {
            display: none;
        }
        
        .mobile-mode #gamepadStatus {
            display: none;
        }
        
        .mobile-mode #mobileIndicator {
            display: block;
        }
        
        @media (max-width: 1000px) {
            canvas {
                width: 100vw;
                max-width: 960px;
                height: auto;
            }
            .game-btn {
                width: 50px;
                height: 45px;
            }
        }
        
        /* Modo m√≥vil horizontal - pantalla completa adaptativa */
        @media (max-width: 1000px) and (orientation: landscape) {
            body {
                padding: 0;
                margin: 0;
            }
            
            #gameContainer {
                width: 100vw;
                height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            
            #title {
                font-size: 16px;
                margin-bottom: 2px;
            }
            
            #subtitle {
                font-size: 9px;
                margin-bottom: 4px;
            }
            
            canvas {
                width: 100vw !important;
                height: calc(100vw * 0.5625) !important;
                max-height: 85vh;
                max-width: calc(85vh / 0.5625);
            }
            
            #mobileIndicator {
                font-size: 10px;
                margin-top: 2px;
            }
        }
        
        /* M√≥vil vertical - mensaje para girar */
        @media (max-width: 600px) and (orientation: portrait) {
            #rotateMessage {
                display: flex !important;
            }
            
            #gameContainer {
                display: none !important;
            }
        }
        
        #rotateMessage {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 100%);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: #ffd700;
            font-family: 'Courier New', monospace;
            text-align: center;
            padding: 20px;
        }
        
        #rotateMessage .rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotatePhone 2s ease-in-out infinite;
        }
        
        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        #rotateMessage h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #rotateMessage p {
            font-size: 14px;
            color: #00bcd4;
        }
        
        /* Input para iniciales en m√≥vil */
        #mobileInitialsContainer {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 30, 0.98);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            z-index: 10000;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        
        #mobileInitialsContainer h3 {
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        #mobileInitialsContainer p {
            color: #fff;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        #mobileInitialsInput {
            font-size: 32px;
            font-family: 'Courier New', monospace;
            text-align: center;
            width: 120px;
            padding: 10px;
            background: #1a1a3a;
            border: 2px solid #4a4a8a;
            border-radius: 8px;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 8px;
        }
        
        #mobileInitialsInput:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        #confirmInitialsBtn {
            display: block;
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(145deg, #2a6a2a, #1a4a1a);
            border: 2px solid #4a8a4a;
            border-radius: 10px;
            color: #0f0;
            cursor: pointer;
            width: 100%;
        }
        
        #confirmInitialsBtn:active {
            background: linear-gradient(145deg, #4a9a4a, #2a6a2a);
        }
    </style>
</head>
<body>
    <!-- Mensaje para girar el tel√©fono -->
    <div id="rotateMessage">
        <div class="rotate-icon">üì±</div>
        <h2>¬°GIRA TU TEL√âFONO!</h2>
        <p>Para jugar, coloca el dispositivo en posici√≥n horizontal</p>
    </div>
    
    <!-- Input nativo para iniciales en m√≥vil -->
    <div id="mobileInitialsContainer">
        <h3>üèÜ ¬°NUEVO RECORD!</h3>
        <p>Ingresa tus iniciales:</p>
        <input type="text" id="mobileInitialsInput" maxlength="3" placeholder="AAA" autocomplete="off" autocapitalize="characters">
        <button id="confirmInitialsBtn">‚úì CONFIRMAR</button>
    </div>
    
    <div id="gameContainer">
        <div id="title">üêä R√çO SALVAJE ü¶´</div>
        <div id="subtitle">Carreras en el Litoral Argentino</div>
        
        <canvas id="gameCanvas" width="960" height="540"></canvas>
        
        <div id="controls">
            <div class="control-group">
                <div class="control-label">D-Pad / Flechas</div>
                <div class="dpad-container">
                    <div class="dpad-spacer"></div>
                    <button class="game-btn dpad" id="btnUp" data-key="up">‚ñ≤</button>
                    <div class="dpad-spacer"></div>
                    <button class="game-btn dpad" id="btnLeft" data-key="left">‚óÄ</button>
                    <button class="game-btn dpad" id="btnDown" data-key="down">‚ñº</button>
                    <button class="game-btn dpad" id="btnRight" data-key="right">‚ñ∂</button>
                </div>
                <div class="control-label">‚óÄ Frenar | ‚ñ∂ Acelerar | ‚ñ≤‚ñº Inclinar</div>
            </div>
            
            <div class="control-group">
                <div class="control-label">Botones de Acci√≥n</div>
                <div class="btn-row">
                    <button class="game-btn accel" id="btn1" data-key="accel">1<br><small>A</small></button>
                    <button class="game-btn jump" id="btn2" data-key="jump">2<br><small>S</small></button>
                    <button class="game-btn start" id="btn3" data-key="start">3<br><small>D</small></button>
                </div>
                <div class="control-label">Acelerar / Saltar / Iniciar</div>
            </div>
        </div>
        
        <div id="instructions">
            <span class="key-hint">A</span> o <span class="key-hint">Bot√≥n 1</span> o <span class="key-hint">‚Üí</span> = Acelerar | 
            <span class="key-hint">‚Üê</span> = Frenar |
            <span class="key-hint">S</span> o <span class="key-hint">Bot√≥n 2</span> = Saltar | 
            <span class="key-hint">D</span> o <span class="key-hint">Bot√≥n 3</span> = Iniciar/Reiniciar | 
            <span class="key-hint">‚Üë‚Üì</span> = Inclinar en el aire
        </div>
        <div id="gamepadStatus">üéÆ Conecta un joystick USB para jugar</div>
        <div id="mobileIndicator">üì± TOCA LA PANTALLA PARA SALTAR ‚Ä¢ Aceleraci√≥n autom√°tica</div>
    </div>

<script>
// =============================================================================
// R√çO SALVAJE - JUEGO DE CARRERAS EN EL R√çO
// Tema: Litoral Argentino con Jacarand√°s, Ceibos y Estrellas Federales
// =============================================================================

// Detectar si es dispositivo m√≥vil
const isMobileDevice = () => {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           ('ontouchstart' in window) ||
           (navigator.maxTouchPoints > 0) ||
           (window.innerWidth <= 800);
};

const IS_MOBILE = isMobileDevice();

// Aplicar clase de m√≥vil al body si es necesario
if (IS_MOBILE) {
    document.body.classList.add('mobile-mode');
}

const CONFIG = {
    WIDTH: 960,
    HEIGHT: 540,
    GRAVITY: 0.35,              // Reducida para saltos m√°s largos y horizontales
    WATER_LEVEL: 400,
    GROUND_FRICTION: 0.985,
    AIR_RESISTANCE: 0.999,      // Muy poca resistencia para mantener velocidad horizontal en vuelo
    MIN_SPEED: 2,
    MAX_SPEED: 18,
    BASE_SCROLL_SPEED: 3,
    SPAWN_INTERVAL: 1800,
    MAX_RECORDS: 10,
    MAX_LIVES: 5,
    IS_MOBILE: IS_MOBILE
};

// Caracteres disponibles para iniciales
const INITIAL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*-+= '.split('');

// =============================================================================
// PERSONAJES
// =============================================================================
const CHARACTERS = {
    YACARE: {
        name: "Yacar√©",
        description: "Lancha - Pesado y Estable",
        acceleration: 0.12,
        jumpPower: 10,          // Fuerza de salto moderada
        airControl: 0.06,       // Control moderado en el aire
        maxRotation: 0.5,       // Menos rotaci√≥n m√°xima
        rotationSpeed: 0.05,    // Rotaci√≥n m√°s lenta
        weight: 1.0,            // Peso normal para ca√≠da natural
        width: 85,
        height: 45,
        color: "#1a8f2e",
        accentColor: "#2ecc40",
        outlineColor: "#0d5c1a"
    },
    CARPINCHO: {
        name: "Carpincho",
        description: "Moto de agua - R√°pido y √Ågil",
        acceleration: 0.2,
        jumpPower: 10,          // Fuerza de salto moderada
        airControl: 0.06,       // Control moderado en el aire
        maxRotation: 0.5,       // Menos rotaci√≥n m√°xima
        rotationSpeed: 0.05,    // Rotaci√≥n m√°s lenta
        weight: 1.0,            // Peso normal para ca√≠da natural
        width: 65,
        height: 38,
        color: "#d4740f",
        accentColor: "#f5a623",
        outlineColor: "#8b4513"
    }
};

// =============================================================================
// CONFIGURACI√ìN DE TIEMPOS DEL D√çA
// =============================================================================
const TIME_OF_DAY = {
    DAY: {
        skyTop: "#3a7ab0",
        skyBottom: "#6ab8d8",
        waterTop: "#145878",
        waterBottom: "#0a3a4a",
        sunColor: "#fff4a3",
        cloudColor: "rgba(255,255,255,0.7)",
        waveIntensity: 1,
        treeLight: 1
    },
    SUNSET: {
        skyTop: "#dd5a2a",
        skyBottom: "#dd9030",
        waterTop: "#904500",
        waterBottom: "#4a2000",
        sunColor: "#ff6347",
        cloudColor: "rgba(255,180,120,0.6)",
        waveIntensity: 1.2,
        treeLight: 0.7
    },
    STORM: {
        skyTop: "#101820",
        skyBottom: "#2a3a4a",
        waterTop: "#102030",
        waterBottom: "#050a10",
        sunColor: "#555",
        cloudColor: "rgba(50,50,60,0.9)",
        waveIntensity: 2.2,
        treeLight: 0.4
    }
};

// =============================================================================
// UTILIDADES
// =============================================================================
const Utils = {
    lerp: (a, b, t) => a + (b - a) * t,
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    random: (min, max) => Math.random() * (max - min) + min,
    randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
};

// =============================================================================
// SISTEMA DE RECORDS
// =============================================================================
class RecordSystem {
    constructor() {
        this.records = this.loadRecords();
    }
    
    loadRecords() {
        try {
            const saved = localStorage.getItem('rioSalvajeRecords');
            return saved ? JSON.parse(saved) : [];
        } catch (e) {
            return [];
        }
    }
    
    saveRecords() {
        try {
            localStorage.setItem('rioSalvajeRecords', JSON.stringify(this.records));
        } catch (e) {
            console.log('No se pudo guardar records');
        }
    }
    
    isHighScore(score) {
        if (this.records.length < CONFIG.MAX_RECORDS) return true;
        return score > this.records[this.records.length - 1].score;
    }
    
    addRecord(initials, score, distance, character) {
        this.records.push({
            initials: initials,
            score: Math.floor(score),
            distance: Math.floor(distance),
            character: character,
            date: new Date().toLocaleDateString()
        });
        this.records.sort((a, b) => b.score - a.score);
        if (this.records.length > CONFIG.MAX_RECORDS) {
            this.records = this.records.slice(0, CONFIG.MAX_RECORDS);
        }
        this.saveRecords();
    }
    
    getRecords() {
        return this.records;
    }
}

// =============================================================================
// SISTEMA DE ENTRADA CON GAMEPAD Y TOUCH M√ìVIL
// =============================================================================
class InputHandler {
    constructor() {
        this.keys = {};
        this.previousKeys = {};
        this.gamepadIndex = null;
        this.gamepadState = {};
        this.previousGamepadState = {};
        this.axisThreshold = 0.5;
        
        // Estado t√°ctil para m√≥vil
        this.touchState = {
            isTouching: false,
            justTouched: false,
            wasTouching: false,
            touchX: 0,
            touchY: 0
        };
        
        // Callback para manejar toques en el men√∫
        this.onMenuTouch = null;
        
        this.setupKeyboardListeners();
        this.setupButtonListeners();
        this.setupGamepadListeners();
        
        // Configurar controles t√°ctiles si es m√≥vil
        if (CONFIG.IS_MOBILE) {
            this.setupTouchListeners();
        }
    }
    
    setupTouchListeners() {
        const canvas = document.getElementById('gameCanvas');
        
        // Toque en el canvas
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.touchState.isTouching = true;
            this.touchState.justTouched = true;
            
            // Guardar posici√≥n del toque (normalizada al canvas)
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = CONFIG.WIDTH / rect.width;
                const scaleY = CONFIG.HEIGHT / rect.height;
                this.touchState.touchX = (e.touches[0].clientX - rect.left) * scaleX;
                this.touchState.touchY = (e.touches[0].clientY - rect.top) * scaleY;
            }
            
            // Llamar callback del men√∫ si existe
            if (this.onMenuTouch) {
                this.onMenuTouch(this.touchState.touchX, this.touchState.touchY);
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.touchState.isTouching = false;
        }, { passive: false });
        
        canvas.addEventListener('touchcancel', (e) => {
            this.touchState.isTouching = false;
        });
        
        // Tambi√©n escuchar clicks del mouse en el canvas (para pruebas)
        canvas.addEventListener('mousedown', (e) => {
            if (CONFIG.IS_MOBILE) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = CONFIG.WIDTH / rect.width;
                const scaleY = CONFIG.HEIGHT / rect.height;
                this.touchState.touchX = (e.clientX - rect.left) * scaleX;
                this.touchState.touchY = (e.clientY - rect.top) * scaleY;
                
                this.touchState.isTouching = true;
                this.touchState.justTouched = true;
                
                if (this.onMenuTouch) {
                    this.onMenuTouch(this.touchState.touchX, this.touchState.touchY);
                }
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (CONFIG.IS_MOBILE) {
                this.touchState.isTouching = false;
            }
        });
    }

    setupKeyboardListeners() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
    }

    setupButtonListeners() {
        const buttons = document.querySelectorAll('.game-btn');
        
        buttons.forEach(btn => {
            const key = btn.dataset.key;
            
            const pressHandler = (e) => {
                e.preventDefault();
                this.setKey(key, true);
                btn.classList.add('pressed');
            };
            
            const releaseHandler = (e) => {
                e.preventDefault();
                this.setKey(key, false);
                btn.classList.remove('pressed');
            };
            
            btn.addEventListener('mousedown', pressHandler);
            btn.addEventListener('mouseup', releaseHandler);
            btn.addEventListener('mouseleave', releaseHandler);
            btn.addEventListener('touchstart', pressHandler);
            btn.addEventListener('touchend', releaseHandler);
        });
    }
    
    setupGamepadListeners() {
        window.addEventListener('gamepadconnected', (e) => {
            this.gamepadIndex = e.gamepad.index;
            document.getElementById('gamepadStatus').textContent = 
                `üéÆ Joystick conectado: ${e.gamepad.id}`;
            document.getElementById('gamepadStatus').style.color = '#0f0';
        });
        
        window.addEventListener('gamepaddisconnected', (e) => {
            if (e.gamepad.index === this.gamepadIndex) {
                this.gamepadIndex = null;
                document.getElementById('gamepadStatus').textContent = 
                    'üéÆ Joystick desconectado';
                document.getElementById('gamepadStatus').style.color = '#f00';
            }
        });
    }
    
    pollGamepad() {
        if (this.gamepadIndex === null) return;
        
        const gamepads = navigator.getGamepads();
        const gp = gamepads[this.gamepadIndex];
        
        if (!gp) return;
        
        // Guardar estado anterior
        this.previousGamepadState = { ...this.gamepadState };
        
        // Leer ejes (joystick/d-pad anal√≥gico)
        this.gamepadState.axisLeft = gp.axes[0] < -this.axisThreshold;
        this.gamepadState.axisRight = gp.axes[0] > this.axisThreshold;
        this.gamepadState.axisUp = gp.axes[1] < -this.axisThreshold;
        this.gamepadState.axisDown = gp.axes[1] > this.axisThreshold;
        
        // Segundo stick si existe
        if (gp.axes.length >= 4) {
            this.gamepadState.axisLeft = this.gamepadState.axisLeft || gp.axes[2] < -this.axisThreshold;
            this.gamepadState.axisRight = this.gamepadState.axisRight || gp.axes[2] > this.axisThreshold;
            this.gamepadState.axisUp = this.gamepadState.axisUp || gp.axes[3] < -this.axisThreshold;
            this.gamepadState.axisDown = this.gamepadState.axisDown || gp.axes[3] > this.axisThreshold;
        }
        
        // MAPEO DE BOTONES CORREGIDO PARA JOYSTICK GEN√âRICO USB
        // Bot√≥n 1 (acelerar) = bot√≥n 0 (generalmente A/Cruz)
        // Bot√≥n 2 (saltar) = bot√≥n 1 (generalmente B/C√≠rculo) 
        // Bot√≥n 3 (start/iniciar) = bot√≥n 2, 3, 4, 5, 6, 7, 8, 9 (probar varios)
        this.gamepadState.button1 = gp.buttons[0]?.pressed || false;
        this.gamepadState.button2 = gp.buttons[1]?.pressed || false;
        
        // Bot√≥n 3 - verificar TODOS los botones posibles para start/select
        this.gamepadState.button3 = 
            gp.buttons[2]?.pressed || 
            gp.buttons[3]?.pressed || 
            gp.buttons[4]?.pressed || 
            gp.buttons[5]?.pressed || 
            gp.buttons[6]?.pressed || 
            gp.buttons[7]?.pressed || 
            gp.buttons[8]?.pressed || 
            gp.buttons[9]?.pressed || 
            gp.buttons[10]?.pressed || 
            gp.buttons[11]?.pressed || 
            false;
        
        // D-pad digital (botones 12-15)
        this.gamepadState.dpadUp = gp.buttons[12]?.pressed || false;
        this.gamepadState.dpadDown = gp.buttons[13]?.pressed || false;
        this.gamepadState.dpadLeft = gp.buttons[14]?.pressed || false;
        this.gamepadState.dpadRight = gp.buttons[15]?.pressed || false;
        
        // Debug: mostrar qu√© botones est√°n presionados
        let pressedButtons = [];
        for (let i = 0; i < gp.buttons.length; i++) {
            if (gp.buttons[i]?.pressed) {
                pressedButtons.push(i);
            }
        }
        if (pressedButtons.length > 0) {
            document.getElementById('gamepadStatus').textContent = 
                `üéÆ Botones: ${pressedButtons.join(', ')}`;
        }
        
        this.updateButtonVisuals();
    }
    
    updateButtonVisuals() {
        const btn1 = document.getElementById('btn1');
        const btn2 = document.getElementById('btn2');
        const btn3 = document.getElementById('btn3');
        const btnUp = document.getElementById('btnUp');
        const btnDown = document.getElementById('btnDown');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        
        if (this.gamepadState.button1) btn1?.classList.add('pressed');
        else if (!this.keys['KeyA']) btn1?.classList.remove('pressed');
        
        if (this.gamepadState.button2) btn2?.classList.add('pressed');
        else if (!this.keys['KeyS']) btn2?.classList.remove('pressed');
        
        if (this.gamepadState.button3) btn3?.classList.add('pressed');
        else if (!this.keys['KeyD']) btn3?.classList.remove('pressed');
        
        if (this.gamepadState.axisUp || this.gamepadState.dpadUp) btnUp?.classList.add('pressed');
        else if (!this.keys['ArrowUp']) btnUp?.classList.remove('pressed');
        
        if (this.gamepadState.axisDown || this.gamepadState.dpadDown) btnDown?.classList.add('pressed');
        else if (!this.keys['ArrowDown']) btnDown?.classList.remove('pressed');
        
        if (this.gamepadState.axisLeft || this.gamepadState.dpadLeft) btnLeft?.classList.add('pressed');
        else if (!this.keys['ArrowLeft']) btnLeft?.classList.remove('pressed');
        
        if (this.gamepadState.axisRight || this.gamepadState.dpadRight) btnRight?.classList.add('pressed');
        else if (!this.keys['ArrowRight']) btnRight?.classList.remove('pressed');
    }

    setKey(key, value) {
        switch(key) {
            case 'left': this.keys['ArrowLeft'] = value; break;
            case 'right': this.keys['ArrowRight'] = value; break;
            case 'up': this.keys['ArrowUp'] = value; break;
            case 'down': this.keys['ArrowDown'] = value; break;
            case 'accel': this.keys['KeyA'] = value; break;
            case 'jump': this.keys['KeyS'] = value; break;
            case 'start': this.keys['KeyD'] = value; break;
        }
    }

    isAccelerating() {
        // En m√≥vil, siempre acelera autom√°ticamente
        if (CONFIG.IS_MOBILE) return true;
        return this.keys['KeyA'] || this.gamepadState.button1 || false;
    }

    isJumping() {
        // En m√≥vil, tocar la pantalla = saltar
        if (CONFIG.IS_MOBILE) return this.touchState.isTouching;
        return this.keys['KeyS'] || this.gamepadState.button2 || false;
    }

    isStarting() {
        // En m√≥vil, tocar tambi√©n puede iniciar
        if (CONFIG.IS_MOBILE) return this.touchState.isTouching;
        return this.keys['KeyD'] || this.gamepadState.button3 || false;
    }

    isTiltingUp() {
        return this.keys['ArrowUp'] || this.keys['KeyW'] || 
               this.gamepadState.axisUp || this.gamepadState.dpadUp || false;
    }

    isTiltingDown() {
        return this.keys['ArrowDown'] || 
               this.gamepadState.axisDown || this.gamepadState.dpadDown || false;
    }

    isTiltingLeft() {
        return this.keys['ArrowLeft'] || 
               this.gamepadState.axisLeft || this.gamepadState.dpadLeft || false;
    }

    isTiltingRight() {
        return this.keys['ArrowRight'] || 
               this.gamepadState.axisRight || this.gamepadState.dpadRight || false;
    }

    isJustPressed(key) {
        const current = this.keys[key];
        const previous = this.previousKeys[key];
        return current && !previous;
    }
    
    isGamepadJustPressed(button) {
        return this.gamepadState[button] && !this.previousGamepadState[button];
    }

    isStartJustPressed() {
        // En m√≥vil, tocar inicia el juego
        if (CONFIG.IS_MOBILE) {
            return this.touchState.justTouched && !this.touchState.wasTouching;
        }
        return this.isJustPressed('KeyD') || this.isGamepadJustPressed('button3');
    }

    isJumpJustPressed() {
        // En m√≥vil, tocar salta
        if (CONFIG.IS_MOBILE) {
            return this.touchState.justTouched && !this.touchState.wasTouching;
        }
        return this.isJustPressed('KeyS') || this.isGamepadJustPressed('button2');
    }
    
    isUpJustPressed() {
        return this.isJustPressed('ArrowUp') || 
               (this.gamepadState.axisUp && !this.previousGamepadState.axisUp) ||
               (this.gamepadState.dpadUp && !this.previousGamepadState.dpadUp);
    }
    
    isDownJustPressed() {
        return this.isJustPressed('ArrowDown') || 
               (this.gamepadState.axisDown && !this.previousGamepadState.axisDown) ||
               (this.gamepadState.dpadDown && !this.previousGamepadState.dpadDown);
    }
    
    isLeftJustPressed() {
        return this.isJustPressed('ArrowLeft') || 
               (this.gamepadState.axisLeft && !this.previousGamepadState.axisLeft) ||
               (this.gamepadState.dpadLeft && !this.previousGamepadState.dpadLeft);
    }
    
    isRightJustPressed() {
        return this.isJustPressed('ArrowRight') || 
               (this.gamepadState.axisRight && !this.previousGamepadState.axisRight) ||
               (this.gamepadState.dpadRight && !this.previousGamepadState.dpadRight);
    }
    
    isButton1JustPressed() {
        return this.isJustPressed('KeyA') || this.isGamepadJustPressed('button1');
    }

    update() {
        this.previousKeys = { ...this.keys };
        this.pollGamepad();
        
        // Actualizar estado t√°ctil
        this.touchState.wasTouching = this.touchState.isTouching;
        this.touchState.justTouched = false;
    }
}

// =============================================================================
// SISTEMA DE AGUA
// =============================================================================
class WaterSystem {
    constructor() {
        this.waves = [
            { amplitude: 4, frequency: 0.018, speed: 0.04, phase: 0 },
            { amplitude: 6, frequency: 0.012, speed: 0.025, phase: 50 },
            { amplitude: 2.5, frequency: 0.028, speed: 0.06, phase: 100 }
        ];
        this.time = 0;
        this.waveIntensity = 1;
    }

    update(dt) {
        this.time += dt;
    }

    getWaveHeight(x, scrollOffset = 0) {
        let height = 0;
        for (const wave of this.waves) {
            height += Math.sin((x * wave.frequency) + (this.time * wave.speed * 60) + wave.phase) 
                     * wave.amplitude * this.waveIntensity;
        }
        return height;
    }

    draw(ctx, timeOfDay, scrollOffset) {
        const colors = TIME_OF_DAY[timeOfDay];
        this.waveIntensity = colors.waveIntensity;
        
        const gradient = ctx.createLinearGradient(0, CONFIG.WATER_LEVEL, 0, CONFIG.HEIGHT);
        gradient.addColorStop(0, colors.waterTop);
        gradient.addColorStop(0.4, colors.waterBottom);
        gradient.addColorStop(1, '#000');

        ctx.beginPath();
        ctx.moveTo(0, CONFIG.WATER_LEVEL);
        
        for (let x = 0; x <= CONFIG.WIDTH; x += 3) {
            ctx.lineTo(x, CONFIG.WATER_LEVEL + this.getWaveHeight(x, scrollOffset));
        }
        
        ctx.lineTo(CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.lineTo(0, CONFIG.HEIGHT);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = 0; x <= CONFIG.WIDTH; x += 3) {
            const y = CONFIG.WATER_LEVEL + this.getWaveHeight(x, scrollOffset) - 2;
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        for (let i = 0; i < 15; i++) {
            const baseX = (i * 80) % CONFIG.WIDTH;
            const reflectX = baseX + Math.sin(this.time * 0.5 + i) * 20;
            const reflectY = CONFIG.WATER_LEVEL + 30 + Math.sin(this.time * 1.5 + i) * 10;
            ctx.beginPath();
            ctx.ellipse(reflectX, reflectY, 25 + Math.sin(this.time + i) * 8, 3, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// =============================================================================
// FONDO DEL LITORAL ARGENTINO - REDISE√ëADO Y ORDENADO
// =============================================================================
class LitoralBackground {
    constructor() {
        // Generar elementos del paisaje de forma ordenada
        this.barrancas = this.generateBarrancas();
        this.treesOnBarrancas = this.generateTreesOnBarrancas();
        this.estrellasF = this.generateEstrellasFederales();
        this.juncos = this.generateJuncos();
    }

    generateBarrancas() {
        const barrancas = [];
        // Barrancas distribuidas uniformemente
        for (let i = 0; i < 5; i++) {
            barrancas.push({
                baseX: i * 280 + 50,
                width: Utils.random(200, 350),
                height: Utils.random(120, 180),
                hasTree: Math.random() > 0.3, // 70% tienen √°rbol
                treeType: Math.random() > 0.5 ? 'jacaranda' : 'ceibo'
            });
        }
        return barrancas;
    }

    generateTreesOnBarrancas() {
        // Los √°rboles ahora se generan EN las barrancas
        return [];
    }

    generateEstrellasFederales() {
        const flores = [];
        // Flores cerca del agua, distribuidas uniformemente - m√°s peque√±as y menos frecuentes
        for (let i = 0; i < 12; i++) {
            flores.push({
                baseX: i * 140 + Utils.random(0, 60),
                scale: Utils.random(0.4, 0.7)
            });
        }
        return flores;
    }

    generateJuncos() {
        const juncos = [];
        for (let i = 0; i < 50; i++) {
            juncos.push({
                baseX: i * 25,
                height: 20 + Math.random() * 25,
                lean: (Math.random() - 0.5) * 8
            });
        }
        return juncos;
    }

    getParallaxX(baseX, scrollOffset, speed, wrapWidth) {
        let x = baseX - (scrollOffset * speed);
        x = ((x % wrapWidth) + wrapWidth) % wrapWidth;
        return x - 100;
    }

    draw(ctx, scrollOffset, timeOfDay, gameTime) {
        const colors = TIME_OF_DAY[timeOfDay];
        const lightMod = colors.treeLight;

        // 1. Dibujar barrancas con √°rboles (fondo lejano)
        this.drawBarrancasWithTrees(ctx, scrollOffset, lightMod);

        // 2. Dibujar juncos cerca del agua
        this.drawJuncos(ctx, scrollOffset, lightMod);

        // 3. Dibujar estrellas federales (primer plano, cerca del agua)
        this.drawEstrellasFederales(ctx, scrollOffset, lightMod);
    }

    drawBarrancasWithTrees(ctx, scrollOffset, lightMod) {
        const wrapWidth = 1400;
        // Atenuar el fondo para dar m√°s contraste al personaje
        const bgDim = 0.65;
        
        for (const barranca of this.barrancas) {
            const x = this.getParallaxX(barranca.baseX, scrollOffset, 0.08, wrapWidth);
            
            // Dibujar barranca (acantilado de tierra) - colores m√°s apagados
            const gradient = ctx.createLinearGradient(x, CONFIG.WATER_LEVEL - barranca.height, x, CONFIG.WATER_LEVEL);
            gradient.addColorStop(0, this.adjustColor('#6a3a1a', lightMod * bgDim));
            gradient.addColorStop(0.3, this.adjustColor('#5a2a10', lightMod * bgDim));
            gradient.addColorStop(0.7, this.adjustColor('#4a2d1b', lightMod * bgDim));
            gradient.addColorStop(1, this.adjustColor('#2a1510', lightMod * bgDim));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(x, CONFIG.WATER_LEVEL - 10);
            ctx.lineTo(x + 20, CONFIG.WATER_LEVEL - barranca.height + 20);
            ctx.lineTo(x + barranca.width * 0.3, CONFIG.WATER_LEVEL - barranca.height);
            ctx.lineTo(x + barranca.width * 0.7, CONFIG.WATER_LEVEL - barranca.height + 10);
            ctx.lineTo(x + barranca.width - 20, CONFIG.WATER_LEVEL - barranca.height + 25);
            ctx.lineTo(x + barranca.width, CONFIG.WATER_LEVEL - 10);
            ctx.closePath();
            ctx.fill();

            // Textura de la barranca
            ctx.strokeStyle = this.adjustColor('#3a1a0a', lightMod * bgDim);
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const lineY = CONFIG.WATER_LEVEL - barranca.height + 30 + i * 25;
                if (lineY < CONFIG.WATER_LEVEL - 15) {
                    ctx.beginPath();
                    ctx.moveTo(x + 10, lineY);
                    ctx.lineTo(x + barranca.width - 10, lineY + 5);
                    ctx.stroke();
                }
            }

            // Pasto en la parte superior de la barranca - m√°s apagado
            ctx.fillStyle = this.adjustColor('#3a5a2a', lightMod * bgDim);
            ctx.beginPath();
            ctx.moveTo(x + 15, CONFIG.WATER_LEVEL - barranca.height + 20);
            ctx.lineTo(x + barranca.width * 0.3, CONFIG.WATER_LEVEL - barranca.height - 5);
            ctx.lineTo(x + barranca.width * 0.7, CONFIG.WATER_LEVEL - barranca.height + 5);
            ctx.lineTo(x + barranca.width - 25, CONFIG.WATER_LEVEL - barranca.height + 20);
            ctx.closePath();
            ctx.fill();

            // Dibujar √°rbol si tiene
            if (barranca.hasTree) {
                const treeX = x + barranca.width * 0.5;
                const treeY = CONFIG.WATER_LEVEL - barranca.height - 10;
                
                if (barranca.treeType === 'jacaranda') {
                    this.drawJacaranda(ctx, treeX, treeY, 1, lightMod * bgDim);
                } else {
                    this.drawCeibo(ctx, treeX, treeY, 1, lightMod * bgDim);
                }
            }
        }
    }

    drawJacaranda(ctx, x, y, scale, lightMod) {
        // Tronco
        ctx.fillStyle = this.adjustColor('#4a3020', lightMod);
        ctx.fillRect(x - 8 * scale, y, 16 * scale, 60 * scale);

        // Copa con flores violetas
        const flowerColors = ['#9b59b6', '#8e44ad', '#a569bd', '#7d3c98'];
        for (let i = 0; i < 25; i++) {
            const angle = (i / 25) * Math.PI * 2;
            const radius = 35 + (i % 4) * 10;
            const fx = x + Math.cos(angle) * radius * scale * 0.8;
            const fy = y - 30 * scale + Math.sin(angle) * radius * 0.4 * scale;
            const fr = (8 + (i % 3) * 4) * scale;
            
            ctx.fillStyle = this.adjustColor(flowerColors[i % flowerColors.length], lightMod);
            ctx.beginPath();
            ctx.arc(fx, fy, fr, 0, Math.PI * 2);
            ctx.fill();
        }

        // Hojas verdes entre las flores
        ctx.fillStyle = this.adjustColor('#2d5a27', lightMod * 0.9);
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const lx = x + Math.cos(angle) * 25 * scale;
            const ly = y - 25 * scale + Math.sin(angle) * 15 * scale;
            ctx.beginPath();
            ctx.ellipse(lx, ly, 8 * scale, 4 * scale, angle, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawCeibo(ctx, x, y, scale, lightMod) {
        // Tronco grueso y retorcido
        ctx.fillStyle = this.adjustColor('#5a4030', lightMod);
        ctx.beginPath();
        ctx.moveTo(x - 12 * scale, y + 55 * scale);
        ctx.quadraticCurveTo(x - 8 * scale, y + 30 * scale, x - 3 * scale, y);
        ctx.quadraticCurveTo(x + 3 * scale, y - 5 * scale, x + 6 * scale, y);
        ctx.quadraticCurveTo(x + 10 * scale, y + 30 * scale, x + 14 * scale, y + 55 * scale);
        ctx.closePath();
        ctx.fill();

        // Flores rojas del ceibo (flor nacional argentina)
        const flowerColors = ['#e74c3c', '#c0392b', '#ff6b6b', '#d63031'];
        for (let i = 0; i < 30; i++) {
            const angle = (i / 30) * Math.PI * 2;
            const radius = 30 + (i % 4) * 8;
            const fx = x + Math.cos(angle) * radius * scale * 0.7;
            const fy = y - 20 * scale + Math.sin(angle) * radius * 0.35 * scale;
            const rotation = i * 0.5;
            
            ctx.fillStyle = this.adjustColor(flowerColors[i % flowerColors.length], lightMod);
            ctx.save();
            ctx.translate(fx, fy);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.ellipse(0, 0, 4 * scale, 12 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Hojas verdes
        ctx.fillStyle = this.adjustColor('#27ae60', lightMod);
        for (let i = 0; i < 15; i++) {
            const angle = (i / 15) * Math.PI * 2;
            const radius = 35 + (i % 3) * 6;
            const lx = x + Math.cos(angle) * radius * scale * 0.6;
            const ly = y - 10 * scale + Math.sin(angle) * radius * 0.25 * scale;
            ctx.beginPath();
            ctx.ellipse(lx, ly, 10 * scale, 5 * scale, angle * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawEstrellasFederales(ctx, scrollOffset, lightMod) {
        const wrapWidth = 1600;
        const waterY = CONFIG.WATER_LEVEL - 8; // Muy cerca del agua
        // Atenuar flores para que no compitan con el personaje
        const florDim = 0.6;
        
        for (const flor of this.estrellasF) {
            const x = this.getParallaxX(flor.baseX, scrollOffset, 0.5, wrapWidth);
            const scale = flor.scale;
            const florY = waterY - 20 * scale;

            // Tallo verde - m√°s apagado
            ctx.strokeStyle = this.adjustColor('#1a6a1a', lightMod * florDim);
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(x, waterY);
            ctx.lineTo(x, florY);
            ctx.stroke();

            // Hojas en el tallo - m√°s peque√±as y apagadas
            ctx.fillStyle = this.adjustColor('#1a8a4a', lightMod * florDim);
            ctx.beginPath();
            ctx.ellipse(x - 4 * scale, florY + 10 * scale, 6 * scale, 3 * scale, -0.5, 0, Math.PI * 2);
            ctx.fill();

            // Br√°cteas rojas m√°s oscuras/apagadas
            ctx.fillStyle = this.adjustColor('#8a2a1a', lightMod * florDim);
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                ctx.save();
                ctx.translate(x, florY);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.ellipse(0, -6 * scale, 2.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Centro m√°s peque√±o y apagado
            ctx.fillStyle = this.adjustColor('#a08000', lightMod * florDim);
            ctx.beginPath();
            ctx.arc(x, florY, 3 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawJuncos(ctx, scrollOffset, lightMod) {
        const wrapWidth = 1300;
        // Atenuar juncos para que no distraigan
        const juncoDim = 0.55;
        
        for (const junco of this.juncos) {
            const x = this.getParallaxX(junco.baseX, scrollOffset, 0.4, wrapWidth);
            
            // Tallo del junco - m√°s delgado y oscuro
            ctx.strokeStyle = this.adjustColor('#2a4a2a', lightMod * juncoDim);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, CONFIG.WATER_LEVEL - 5);
            ctx.quadraticCurveTo(
                x + junco.lean * 0.5,
                CONFIG.WATER_LEVEL - junco.height / 2,
                x + junco.lean,
                CONFIG.WATER_LEVEL - junco.height
            );
            ctx.stroke();

            // Espiga del junco - m√°s peque√±a
            ctx.fillStyle = this.adjustColor('#5a4a35', lightMod * juncoDim);
            ctx.beginPath();
            ctx.ellipse(
                x + junco.lean, 
                CONFIG.WATER_LEVEL - junco.height - 6, 
                2, 7, 0, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }

    adjustColor(hexColor, lightMod) {
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);
        
        const newR = Math.floor(Utils.clamp(r * lightMod, 0, 255));
        const newG = Math.floor(Utils.clamp(g * lightMod, 0, 255));
        const newB = Math.floor(Utils.clamp(b * lightMod, 0, 255));
        
        return `rgb(${newR},${newG},${newB})`;
    }
}

// =============================================================================
// JUGADOR
// =============================================================================
class Player {
    constructor(characterType) {
        this.stats = CHARACTERS[characterType];
        this.characterType = characterType;
        this.reset();
    }

    reset() {
        this.x = 180;
        this.y = CONFIG.WATER_LEVEL - 25;
        this.vx = CONFIG.BASE_SCROLL_SPEED;
        this.vy = 0;
        this.rotation = 0;
        this.isAirborne = false;
        this.crashed = false;
        this.boostTimer = 0;
        this.invincibleTimer = 0;
        this.splashParticles = [];
        this.canJump = true;
        this.jumpCooldown = 0;
    }

    update(input, waterSystem, scrollOffset, dt) {
        if (this.crashed) {
            this.updateSplash();
            return;
        }

        // Acelerar con A/Bot√≥n1 o Flecha derecha/Palanca derecha
        if (input.isAccelerating() || input.isTiltingRight()) {
            this.vx += this.stats.acceleration;
        } 
        // Frenar con Flecha izquierda/Palanca izquierda
        else if (input.isTiltingLeft()) {
            this.vx -= this.stats.acceleration * 0.8;
        }
        else {
            this.vx *= 0.995;
        }

        this.vx = Utils.clamp(this.vx, CONFIG.MIN_SPEED, CONFIG.MAX_SPEED);

        if (this.jumpCooldown > 0) {
            this.jumpCooldown -= dt;
        }

        if (input.isJumpJustPressed() && !this.isAirborne && this.jumpCooldown <= 0) {
            this.jump(1.0);
            this.jumpCooldown = 0.3;
        }

        if (this.boostTimer > 0) {
            this.boostTimer -= dt;
            this.vx = Math.min(this.vx * 1.008, CONFIG.MAX_SPEED * 1.4);
        }

        if (this.invincibleTimer > 0) {
            this.invincibleTimer -= dt;
        }

        if (this.isAirborne) {
            this.vy += CONFIG.GRAVITY * this.stats.weight;
            
            // Solo arriba/abajo inclinan el veh√≠culo en el aire
            if (input.isTiltingUp()) {
                this.rotation -= this.stats.rotationSpeed;
            }
            if (input.isTiltingDown()) {
                this.rotation += this.stats.rotationSpeed;
            }
            
            this.rotation = Utils.clamp(this.rotation, -this.stats.maxRotation, this.stats.maxRotation);
            this.vx *= CONFIG.AIR_RESISTANCE;
            this.y += this.vy;

            // Limitar altura m√°xima para que no se salga de la pantalla
            const minY = 60; // Margen superior m√≠nimo (menos restrictivo ahora)
            if (this.y < minY) {
                this.y = minY;
                this.vy = Math.abs(this.vy) * 0.5; // Rebote m√°s suave hacia abajo
            }

            const waterHeight = CONFIG.WATER_LEVEL + waterSystem.getWaveHeight(this.x, scrollOffset);
            if (this.y >= waterHeight - 15) {
                this.land(waterHeight);
            }
        } else {
            const waterHeight = CONFIG.WATER_LEVEL + waterSystem.getWaveHeight(this.x, scrollOffset);
            this.y = waterHeight - 15;
            this.rotation *= 0.85;
            this.vx *= CONFIG.GROUND_FRICTION;
        }

        this.x = Utils.clamp(this.x, 80, CONFIG.WIDTH - 120);
        
        this.updateSplash();
    }

    jump(multiplier = 1) {
        if (!this.isAirborne && !this.crashed) {
            // Salto con componente vertical moderado
            this.vy = -this.stats.jumpPower * multiplier;
            // Impulso horizontal adicional basado en la velocidad actual y el multiplicador
            this.vx += this.vx * 0.15 * multiplier;
            this.isAirborne = true;
            this.createSplash();
        }
    }

    land(waterHeight) {
        this.isAirborne = false;
        this.y = waterHeight - 15;
        this.vy = 0;
        this.createSplash();

        const rotationAngle = Math.abs(this.rotation);
        
        if (rotationAngle > 0.5) {
            this.crash();
            return { quality: 'crash', bonus: -500 };
        } else if (rotationAngle > 0.35) {
            this.vx *= 0.5;
            return { quality: 'rough', bonus: 0 };
        } else if (rotationAngle < 0.12) {
            return { quality: 'perfect', bonus: 500 };
        }
        return { quality: 'good', bonus: 100 };
    }

    crash() {
        this.crashed = true;
        this.createBigSplash();
    }

    hitObstacle() {
        if (this.invincibleTimer <= 0) {
            this.vx *= 0.35;
            this.invincibleTimer = 2.5;
            this.createSplash();
            return true;
        }
        return false;
    }

    createSplash() {
        for (let i = 0; i < 10; i++) {
            this.splashParticles.push({
                x: this.x + Utils.random(-25, 25),
                y: this.y,
                vx: Utils.random(-4, 4),
                vy: Utils.random(-8, -3),
                life: 1.2
            });
        }
    }

    createBigSplash() {
        for (let i = 0; i < 25; i++) {
            this.splashParticles.push({
                x: this.x + Utils.random(-35, 35),
                y: this.y,
                vx: Utils.random(-6, 6),
                vy: Utils.random(-12, -4),
                life: 1.8
            });
        }
    }

    updateSplash() {
        this.splashParticles = this.splashParticles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.35;
            p.life -= 0.035;
            return p.life > 0;
        });
    }

    draw(ctx) {
        ctx.fillStyle = 'rgba(200, 230, 255, 0.9)';
        for (const p of this.splashParticles) {
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        if (this.crashed) {
            ctx.save();
            ctx.translate(this.x, this.y + 25);
            ctx.rotate(0.6);
            ctx.globalAlpha = 0.4;
            this.drawVehicle(ctx);
            ctx.restore();
            return;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if (this.invincibleTimer > 0 && Math.floor(this.invincibleTimer * 10) % 2 === 0) {
            ctx.globalAlpha = 0.3;
        }

        // Efecto de resplandor/glow para destacar al personaje
        this.drawGlow(ctx);
        
        this.drawVehicle(ctx);

        if (!this.isAirborne) {
            this.drawWake(ctx);
        }

        if (this.boostTimer > 0) {
            this.drawBoostFlame(ctx);
        }

        ctx.restore();
    }
    
    drawGlow(ctx) {
        // Resplandor exterior para destacar al personaje del fondo
        const glowColor = this.characterType === 'YACARE' ? 'rgba(46, 255, 80, 0.5)' : 'rgba(255, 180, 50, 0.5)';
        const glowColor2 = this.characterType === 'YACARE' ? 'rgba(46, 255, 80, 0.15)' : 'rgba(255, 180, 50, 0.15)';
        
        // Sombra debajo del personaje en el agua
        if (!this.isAirborne) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(5, 20, this.stats.width / 2, 8, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 30;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Dibujar silueta para el glow - m√°s brillante
        ctx.fillStyle = glowColor2;
        ctx.beginPath();
        ctx.ellipse(0, -15, this.stats.width / 2 + 15, this.stats.height / 2 + 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Borde de luz
        ctx.strokeStyle = glowColor;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.shadowBlur = 0;
    }

    drawVehicle(ctx) {
        if (this.characterType === 'YACARE') {
            this.drawYacare(ctx);
        } else {
            this.drawCarpincho(ctx);
        }
    }

    drawYacare(ctx) {
        // Casco de la lancha - colores m√°s brillantes
        ctx.fillStyle = '#7a5040';
        ctx.beginPath();
        ctx.moveTo(-45, 15);
        ctx.lineTo(50, 15);
        ctx.lineTo(62, 0);
        ctx.lineTo(50, -10);
        ctx.lineTo(-40, -10);
        ctx.lineTo(-45, 8);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#2a1a10';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Borde brillante de la lancha
        ctx.strokeStyle = '#c08060';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-42, -8);
        ctx.lineTo(48, -8);
        ctx.stroke();

        ctx.fillStyle = '#9a7a5a';
        ctx.fillRect(-32, -14, 60, 6);

        // Yacar√© - colores m√°s vivos
        ctx.fillStyle = this.stats.color;
        ctx.beginPath();
        ctx.ellipse(-5, -22, 24, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = this.stats.outlineColor;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = this.stats.color;
        ctx.beginPath();
        ctx.ellipse(25, -24, 18, 11, -0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = this.stats.accentColor;
        ctx.beginPath();
        ctx.ellipse(48, -22, 14, 7, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Ojos m√°s brillantes
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(30, -32, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#aa8800';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(31, -32, 3, 0, Math.PI * 2);
        ctx.fill();

        // Dientes
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 5; i++) {
            ctx.fillRect(40 + i * 4, -17, 2, 6);
        }

        // Escamas brillantes
        ctx.fillStyle = this.stats.accentColor;
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.arc(-18 + i * 9, -22, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Patas
        ctx.fillStyle = this.stats.color;
        ctx.strokeStyle = this.stats.outlineColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(-15, -8, 8, 5, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(10, -8, 8, 5, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
    }

    // CARPINCHO REDISE√ëADO - M√°s visible y con mejor contraste
    drawCarpincho(ctx) {
        // Moto de agua - colores m√°s brillantes
        ctx.fillStyle = '#ff4466';
        ctx.beginPath();
        ctx.moveTo(-35, 12);
        ctx.lineTo(40, 12);
        ctx.lineTo(52, 0);
        ctx.lineTo(40, -12);
        ctx.lineTo(-30, -12);
        ctx.lineTo(-35, 5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#aa0020';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Franja blanca brillante
        ctx.fillStyle = '#fff';
        ctx.fillRect(-12, -10, 18, 4);
        
        // Asiento
        ctx.fillStyle = '#333';
        ctx.fillRect(-22, -16, 35, 6);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(-22, -16, 35, 6);

        // Manubrio - m√°s visible
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(5, -16);
        ctx.lineTo(5, -26);
        ctx.stroke();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-8, -30);
        ctx.lineTo(5, -26);
        ctx.lineTo(18, -30);
        ctx.stroke();
        
        // Pu√±os del manubrio
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(-8, -30, 4, 0, Math.PI * 2);
        ctx.arc(18, -30, 4, 0, Math.PI * 2);
        ctx.fill();

        // === CARPINCHO CON MEJOR CONTRASTE ===
        // Cuerpo principal - color m√°s brillante
        ctx.fillStyle = this.stats.color;
        ctx.beginPath();
        ctx.ellipse(0, -32, 26, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = this.stats.outlineColor;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Cabeza
        ctx.fillStyle = this.stats.color;
        ctx.beginPath();
        ctx.ellipse(28, -38, 18, 16, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Hocico - m√°s claro para contraste
        ctx.fillStyle = this.stats.accentColor;
        ctx.beginPath();
        ctx.ellipse(44, -36, 12, 10, 0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = this.stats.outlineColor;
        ctx.stroke();

        // Nariz grande y oscura
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.ellipse(52, -36, 6, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Fosas nasales
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(50, -37, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(54, -37, 2, 0, Math.PI * 2);
        ctx.fill();

        // Orejas
        ctx.fillStyle = this.stats.color;
        ctx.beginPath();
        ctx.ellipse(22, -52, 5, 7, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(32, -52, 5, 7, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Interior de las orejas - m√°s brillante
        ctx.fillStyle = '#ffcc88';
        ctx.beginPath();
        ctx.ellipse(22, -51, 3, 4, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(32, -51, 3, 4, 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Ojos - m√°s grandes y expresivos
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(34, -42, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(35, -43, 2, 0, Math.PI * 2);
        ctx.fill();

        // Bigotes
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(48, -33 + i * 3);
            ctx.lineTo(62, -36 + i * 4);
            ctx.stroke();
        }

        // Pelaje con l√≠neas m√°s claras
        ctx.strokeStyle = this.stats.accentColor;
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(-15 + i * 8, -38);
            ctx.lineTo(-12 + i * 8, -28);
            ctx.stroke();
        }

        // Patas delanteras con contorno
        ctx.fillStyle = this.stats.color;
        ctx.strokeStyle = this.stats.outlineColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(-2, -28, 7, 5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(12, -28, 7, 5, -0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
    }

    drawWake(ctx) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        for (let i = 0; i < 8; i++) {
            const size = 7 - i * 0.7;
            ctx.beginPath();
            ctx.arc(-55 - i * 14, 12 + Math.sin(Date.now() / 80 + i) * 4, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawBoostFlame(ctx) {
        const flicker = Math.sin(Date.now() / 25) * 6;
        ctx.fillStyle = '#ff4400';
        ctx.beginPath();
        ctx.moveTo(-50, 6);
        ctx.lineTo(-80 - flicker, 0);
        ctx.lineTo(-50, -6);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.moveTo(-50, 4);
        ctx.lineTo(-68 - flicker * 0.6, 0);
        ctx.lineTo(-50, -4);
        ctx.closePath();
        ctx.fill();
    }

    getBounds() {
        return {
            x: this.x - this.stats.width / 2,
            y: this.y - this.stats.height,
            width: this.stats.width,
            height: this.stats.height
        };
    }
}

// =============================================================================
// OBST√ÅCULOS
// =============================================================================
class Obstacle {
    constructor(x, type) {
        this.x = x;
        this.type = type;
        this.active = true;
        this.createdAt = Date.now();
        this.setup();
    }

    setup() {
        switch (this.type) {
            case 'log':
                this.width = 100;
                this.height = 25;
                this.y = CONFIG.WATER_LEVEL + 10;
                break;
            case 'buoy':
                this.width = 30;
                this.height = 50;
                this.y = CONFIG.WATER_LEVEL - 18;
                this.bobOffset = Math.random() * Math.PI * 2;
                break;
            case 'net':
                this.width = 120;
                this.height = 40;
                this.y = CONFIG.WATER_LEVEL + 8;
                break;
            case 'boat':
                this.width = 80;
                this.height = 45;
                this.y = CONFIG.WATER_LEVEL - 20;
                break;
            case 'whirlpool':
                this.width = 80;
                this.height = 80;
                this.y = CONFIG.WATER_LEVEL + 20;
                this.rotation = 0;
                break;
            case 'sleepingAnimal':
                this.width = 50;
                this.height = 30;
                this.y = CONFIG.WATER_LEVEL - 10;
                this.animalType = Math.random() > 0.5 ? 'carpincho' : 'yacare';
                this.bobOffset = Math.random() * Math.PI * 2;
                break;
        }
    }

    update(scrollSpeed, time) {
        this.x -= scrollSpeed;
        
        if (this.type === 'buoy' || this.type === 'sleepingAnimal') {
            this.y = CONFIG.WATER_LEVEL - 18 + Math.sin(time * 3 + this.bobOffset) * 7;
        }
        if (this.type === 'whirlpool') {
            this.rotation += 0.15;
        }
        
        if (this.x < -this.width - 60) {
            this.active = false;
        }
    }

    draw(ctx, time) {
        switch (this.type) {
            case 'log': this.drawLog(ctx); break;
            case 'buoy': this.drawBuoy(ctx); break;
            case 'net': this.drawNet(ctx); break;
            case 'boat': this.drawBoat(ctx); break;
            case 'whirlpool': this.drawWhirlpool(ctx); break;
            case 'sleepingAnimal': this.drawSleepingAnimal(ctx, time); break;
        }
    }

    drawLog(ctx) {
        // Glow/resplandor para destacar
        ctx.shadowColor = '#ff6600';
        ctx.shadowBlur = 15;
        
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        ctx.shadowBlur = 0;
        
        // Borde brillante de advertencia
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        
        ctx.strokeStyle = '#5d3a1a';
        ctx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x + i * 18 + 8, this.y);
            ctx.lineTo(this.x + i * 18 + 8, this.y + this.height);
            ctx.stroke();
        }
        
        ctx.fillStyle = '#cd853f';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + this.height / 2, 7, this.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(this.x + this.width, this.y + this.height / 2, 7, this.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#228B22';
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.arc(this.x + 20 + i * 22, this.y + 5, 6, 0, Math.PI);
            ctx.fill();
        }
    }

    drawBuoy(ctx) {
        // Glow para destacar
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20;
        
        ctx.fillStyle = '#888';
        ctx.fillRect(this.x + 12, this.y, 7, this.height);
        
        ctx.fillStyle = '#ff2222';
        ctx.beginPath();
        ctx.arc(this.x + 15, this.y, 18, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
        // Franjas blancas brillantes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x, this.y - 8, 30, 16);
        
        // Borde rojo
        ctx.strokeStyle = '#cc0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x + 15, this.y, 18, 0, Math.PI * 2);
        ctx.stroke();
        
        // Luz parpadeante m√°s brillante
        const blink = Math.floor(Date.now() / 300) % 2;
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = blink ? 25 : 5;
        ctx.fillStyle = blink ? '#ffff00' : '#ffaa00';
        ctx.beginPath();
        ctx.arc(this.x + 15, this.y - 16, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    drawNet(ctx) {
        // Glow amarillo para la red
        ctx.shadowColor = '#ffaa00';
        ctx.shadowBlur = 12;
        
        ctx.strokeStyle = '#ffdd44';
        ctx.lineWidth = 3;
        
        for (let i = 0; i <= 5; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + i * 8);
            ctx.lineTo(this.x + this.width, this.y + i * 8);
            ctx.stroke();
        }
        for (let i = 0; i <= 12; i++) {
            ctx.beginPath();
            ctx.moveTo(this.x + i * 10, this.y);
            ctx.lineTo(this.x + i * 10, this.y + this.height);
            ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        
        // Flotadores naranjas brillantes
        ctx.fillStyle = '#ff6600';
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.arc(this.x + i * 24 + 5, this.y - 12, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }
    }

    drawBoat(ctx) {
        // Glow azul para el bote
        ctx.shadowColor = '#4488ff';
        ctx.shadowBlur = 18;
        
        ctx.fillStyle = '#2255aa';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.height);
        ctx.lineTo(this.x + 15, this.y + 15);
        ctx.lineTo(this.x + this.width - 15, this.y + 15);
        ctx.lineTo(this.x + this.width, this.y + this.height);
        ctx.closePath();
        ctx.fill();
        
        // Borde brillante
        ctx.strokeStyle = '#66aaff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        
        // Cabina blanca brillante
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x + 18, this.y - 2, 40, 24);
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x + 18, this.y - 2, 40, 24);
        
        // Ventanas oscuras
        ctx.fillStyle = '#1a1a3a';
        ctx.fillRect(this.x + 23, this.y + 3, 30, 14);
        
        // Luz de advertencia
        const blink = Math.floor(Date.now() / 400) % 2;
        ctx.fillStyle = blink ? '#ff0000' : '#880000';
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y - 8, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    drawWhirlpool(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y);
        ctx.rotate(this.rotation);
        
        // Glow peligroso p√∫rpura/azul
        ctx.shadowColor = '#8800ff';
        ctx.shadowBlur = 30;
        
        // Espirales m√°s coloridas y visibles
        for (let i = 0; i < 6; i++) {
            const hue = 200 + i * 20;
            ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${0.9 - i * 0.1})`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(0, 0, 12 + i * 11, 0, Math.PI * 1.7);
            ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        
        // Centro oscuro con borde brillante
        ctx.fillStyle = '#000022';
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#ff00ff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // S√≠mbolo de peligro
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('!', 0, 6);
        
        ctx.restore();
    }

    drawSleepingAnimal(ctx, time) {
        const breathe = Math.sin(time * 3) * 2;
        
        // Glow suave para destacar
        ctx.shadowColor = '#ffaa00';
        ctx.shadowBlur = 15;
        
        if (this.animalType === 'carpincho') {
            // Carpincho durmiendo - colores m√°s brillantes
            ctx.fillStyle = '#cd8844';
            ctx.beginPath();
            ctx.ellipse(this.x + 25, this.y + 10 + breathe, 28, 18 + breathe, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Borde de contraste
            ctx.strokeStyle = '#885522';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Cabeza
            ctx.fillStyle = '#cd8844';
            ctx.beginPath();
            ctx.ellipse(this.x + 52, this.y + 5, 14, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            
            // Hocico m√°s claro
            ctx.fillStyle = '#e0a060';
            ctx.beginPath();
            ctx.ellipse(this.x + 62, this.y + 6, 8, 6, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Nariz grande y oscura
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.ellipse(this.x + 68, this.y + 5, 5, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Oreja
            ctx.fillStyle = '#cd8844';
            ctx.beginPath();
            ctx.ellipse(this.x + 48, this.y - 4, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ojo cerrado
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x + 56, this.y + 2, 4, 0.2, Math.PI - 0.2);
            ctx.stroke();
        } else {
            // Yacar√© durmiendo - colores m√°s vivos
            ctx.fillStyle = '#3a8a3a';
            ctx.beginPath();
            ctx.ellipse(this.x + 25, this.y + 12 + breathe, 28, 15 + breathe, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#1a4a1a';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Cabeza/hocico
            ctx.fillStyle = '#4a9a4a';
            ctx.beginPath();
            ctx.ellipse(this.x + 55, this.y + 10, 20, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            
            // Dientes
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(this.x + 68 + i * 5, this.y + 8, 3, 5);
            }
            
            // Ojo cerrado
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x + 48, this.y + 5, 4, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        
        // ZZZs m√°s grandes y visibles
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.font = 'bold 18px Arial';
        const zzz = Math.floor(time * 2) % 3;
        const zText = 'z'.repeat(zzz + 1);
        ctx.strokeText(zText, this.x + 55, this.y - 18 - zzz * 6);
        ctx.fillText(zText, this.x + 55, this.y - 18 - zzz * 6);
    }

    getBounds() {
        return {
            x: this.x,
            y: this.y - this.height / 2,
            width: this.width,
            height: this.height
        };
    }
}

// =============================================================================
// RAMPAS
// =============================================================================
class Ramp {
    constructor(x, type) {
        this.x = x;
        this.type = type;
        this.active = true;
        this.used = false;
        this.setup();
    }

    setup() {
        switch (this.type) {
            case 'small':
                this.width = 180;      // Muy ancha para recorrido largo
                this.height = 15;      // Muy baja - √°ngulo muy suave
                this.jumpMultiplier = 1.2;  // Buen impulso hacia adelante
                this.color = '#8b5a2b';
                break;
            case 'large':
                this.width = 280;      // Extra ancha para m√°ximo recorrido
                this.height = 22;      // Baja - √°ngulo suave
                this.jumpMultiplier = 1.5;  // Mayor impulso hacia adelante
                this.color = '#654321';
                break;
            case 'moving':
                this.width = 200;      // Ancha
                this.height = 18;      // Baja
                this.jumpMultiplier = 1.3;  // Buen impulso
                this.color = '#7a6030';
                this.baseY = CONFIG.WATER_LEVEL - 20;
                break;
            case 'broken':
                this.width = 220;      // Ancha
                this.height = 20;      // Baja
                this.jumpMultiplier = 1.4;  // Buen impulso
                this.color = '#5d3a27';
                break;
        }
        this.y = CONFIG.WATER_LEVEL - 12;
    }

    update(scrollSpeed, time) {
        this.x -= scrollSpeed;
        
        if (this.type === 'moving') {
            this.y = this.baseY + Math.sin(time * 2.2) * 28;
        }
        
        if (this.x < -this.width - 60) {
            this.active = false;
        }
    }

    use() {
        if (this.type === 'broken' && !this.used) {
            this.used = true;
            setTimeout(() => { this.active = false; }, 250);
            return true;
        }
        return false;
    }

    draw(ctx) {
        if (!this.active) return;
        
        ctx.save();
        
        // Sombra de la rampa
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.moveTo(this.x + 8, CONFIG.WATER_LEVEL + 10);
        ctx.lineTo(this.x + this.width + 12, CONFIG.WATER_LEVEL + 10);
        ctx.lineTo(this.x + this.width + 12, CONFIG.WATER_LEVEL + 18);
        ctx.lineTo(this.x + 8, CONFIG.WATER_LEVEL + 18);
        ctx.closePath();
        ctx.fill();

        // Rampa principal con gradiente
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y - this.height);
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, '#a07050');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.width, this.y - this.height);
        ctx.lineTo(this.x + this.width, this.y);
        ctx.closePath();
        ctx.fill();

        // Borde superior de la rampa (m√°s visible)
        ctx.strokeStyle = '#4a3020';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.width, this.y - this.height);
        ctx.stroke();
        
        // L√≠nea brillante en el borde
        ctx.strokeStyle = '#c09060';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x + 2, this.y - 2);
        ctx.lineTo(this.x + this.width - 2, this.y - this.height);
        ctx.stroke();

        // L√≠neas de soporte de la rampa
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.lineWidth = 2;
        const numLines = Math.floor(this.width / 20);
        for (let i = 1; i < numLines; i++) {
            const px = this.x + (this.width / numLines) * i;
            const py = this.y - (this.height / numLines) * i;
            ctx.beginPath();
            ctx.moveTo(px, this.y);
            ctx.lineTo(px, py);
            ctx.stroke();
        }

        // Flecha indicadora de direcci√≥n del salto
        ctx.fillStyle = '#ffff00';
        ctx.strokeStyle = '#aa8800';
        ctx.lineWidth = 2;
        const arrowX = this.x + this.width - 20;
        const arrowY = this.y - this.height - 15;
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX + 15, arrowY + 5);
        ctx.lineTo(arrowX + 10, arrowY + 5);
        ctx.lineTo(arrowX + 10, arrowY + 12);
        ctx.lineTo(arrowX - 5, arrowY + 12);
        ctx.lineTo(arrowX - 5, arrowY + 5);
        ctx.lineTo(arrowX - 10, arrowY + 5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        if (this.type === 'moving') {
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + 15, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('‚Üï', this.x + this.width / 2 - 5, this.y + 20);
        }

        if (this.type === 'broken') {
            ctx.strokeStyle = '#1a0a00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x + this.width * 0.3, this.y - this.height * 0.3);
            ctx.lineTo(this.x + this.width * 0.4, this.y - this.height * 0.5);
            ctx.lineTo(this.x + this.width * 0.35, this.y - this.height * 0.6);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.x + this.width * 0.6, this.y - this.height * 0.5);
            ctx.lineTo(this.x + this.width * 0.7, this.y - this.height * 0.8);
            ctx.stroke();
            
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('‚ö†', this.x + this.width / 2 - 8, this.y - this.height - 5);
        }

        if (this.type === 'large') {
            // Franjas de advertencia para rampa grande
            ctx.fillStyle = '#ff0';
            const stripeCount = Math.floor(this.width / 35);
            for (let i = 0; i < stripeCount; i++) {
                const sx = this.x + 15 + i * 35;
                const sy = this.y - (this.height * (15 + i * 35) / this.width) + 5;
                ctx.fillRect(sx, sy, 18, 5);
            }
        }

        ctx.restore();
    }

    getRampHeight(playerX) {
        if (playerX < this.x || playerX > this.x + this.width) return null;
        const progress = (playerX - this.x) / this.width;
        return this.y - (this.height * progress);
    }
}

// =============================================================================
// COLECCIONABLES
// =============================================================================
class Collectible {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.active = true;
        this.collected = false;
        this.animation = 0;
        this.baseY = y;
        
        switch (type) {
            case 'fish': this.value = 150; this.color = '#ffd700'; break;
            case 'star': this.value = 600; this.color = '#ff69b4'; break;
            case 'boost': this.value = 0; this.color = '#00ff00'; break;
            case 'life': this.value = 100; this.color = '#ff4444'; break;
        }
    }

    update(scrollSpeed, time) {
        this.x -= scrollSpeed;
        this.y = this.baseY + Math.sin(time * 4.5) * 10;
        
        if (this.collected) {
            this.animation++;
            if (this.animation > 30) this.active = false;
        }
        
        if (this.x < -50) this.active = false;
    }

    draw(ctx, time) {
        if (this.collected) {
            ctx.globalAlpha = 1 - this.animation / 30;
            ctx.fillStyle = this.color;
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`+${this.value || '‚ö°'}`, this.x - 18, this.y - this.animation * 2.5);
            ctx.globalAlpha = 1;
            return;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        
        const glowSize = 25 + Math.sin(time * 6) * 8;
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        gradient.addColorStop(0, this.color + '99');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();

        if (this.type === 'fish') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-18, 0);
            ctx.lineTo(-32, -12);
            ctx.lineTo(-32, 12);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(12, -2, 3, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'star') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                const x = Math.cos(angle) * 16;
                const y = Math.sin(angle) * 16;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        } else if (this.type === 'boost') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(-5, -14);
            ctx.lineTo(-5, -7);
            ctx.lineTo(-20, -7);
            ctx.lineTo(-20, 7);
            ctx.lineTo(-5, 7);
            ctx.lineTo(-5, 14);
            ctx.closePath();
            ctx.fill();
        } else if (this.type === 'life') {
            // Dibujar coraz√≥n
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(0, 6);
            ctx.bezierCurveTo(-12, -6, -20, 4, -12, 14);
            ctx.lineTo(0, 22);
            ctx.lineTo(12, 14);
            ctx.bezierCurveTo(20, 4, 12, -6, 0, 6);
            ctx.fill();
            
            // Brillo
            ctx.fillStyle = '#ff8888';
            ctx.beginPath();
            ctx.arc(-5, 4, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    checkCollision(playerBounds) {
        return Utils.distance(this.x, this.y, 
            playerBounds.x + playerBounds.width / 2,
            playerBounds.y + playerBounds.height / 2) < 50;
    }

    collect() {
        this.collected = true;
        let effect = null;
        if (this.type === 'boost') effect = 'speed';
        else if (this.type === 'life') effect = 'life';
        return { value: this.value, effect: effect };
    }
}

// =============================================================================
// JUEGO PRINCIPAL
// =============================================================================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = new InputHandler();
        this.waterSystem = new WaterSystem();
        this.background = new LitoralBackground();
        this.recordSystem = new RecordSystem();
        
        this.state = 'menu';
        this.selectedCharacter = 'YACARE';
        this.menuSelection = 0;
        
        this.initials = ['A', 'A', 'A'];
        this.currentInitialIndex = 0;
        this.charIndex = 0;
        
        // Configurar callback para toques en m√≥vil
        if (CONFIG.IS_MOBILE) {
            this.input.onMenuTouch = (x, y) => this.handleMenuTouch(x, y);
        }
        
        this.reset();
        this.lastTime = performance.now();
    }
    
    // Manejar toques en el men√∫ para selecci√≥n de personaje
    handleMenuTouch(x, y) {
        if (this.state === 'menu') {
            // Coordenadas de las casillas de personajes
            const boxLeft = CONFIG.WIDTH / 2 - 260;
            const boxRight = CONFIG.WIDTH / 2 + 260;
            
            // Casilla del Yacar√© (y1 = 255, altura 80)
            const yacare_top = 215;
            const yacare_bottom = 295;
            
            // Casilla del Carpincho (y2 = 360, altura 80)
            const carpincho_top = 320;
            const carpincho_bottom = 400;
            
            if (x >= boxLeft && x <= boxRight) {
                if (y >= yacare_top && y <= yacare_bottom) {
                    // Toc√≥ Yacar√© - seleccionar e iniciar
                    this.menuSelection = 0;
                    this.selectedCharacter = 'YACARE';
                    this.reset();
                    this.state = 'playing';
                    this.tutorialTimer = 6;
                    return;
                } else if (y >= carpincho_top && y <= carpincho_bottom) {
                    // Toc√≥ Carpincho - seleccionar e iniciar
                    this.menuSelection = 1;
                    this.selectedCharacter = 'CARPINCHO';
                    this.reset();
                    this.state = 'playing';
                    this.tutorialTimer = 6;
                    return;
                }
            }
            
            // Si toc√≥ en cualquier otra parte, iniciar con el personaje seleccionado
            this.selectedCharacter = this.menuSelection === 0 ? 'YACARE' : 'CARPINCHO';
            this.reset();
            this.state = 'playing';
            this.tutorialTimer = 6;
        } 
        else if (this.state === 'gameover') {
            // Tocar en game over contin√∫a
            if (this.recordSystem.isHighScore(this.score)) {
                this.state = 'enterInitials';
                this.initials = ['A', 'A', 'A'];
                this.currentInitialIndex = 0;
                this.charIndex = 0;
            } else {
                this.state = 'menu';
                this.menuSelection = 0;
            }
        }
        else if (this.state === 'records') {
            // Tocar en records vuelve al men√∫
            this.state = 'menu';
        }
    }

    reset() {
        this.player = new Player(this.selectedCharacter);
        this.obstacles = [];
        this.ramps = [];
        this.collectibles = [];
        
        this.score = 0;
        this.distance = 0;
        this.lives = CONFIG.MAX_LIVES;
        this.scrollSpeed = CONFIG.BASE_SCROLL_SPEED;
        this.scrollOffset = 0;
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.difficulty = 1;
        
        this.timeOfDay = 'DAY';
        this.timeOfDayTimer = 0;
        
        this.message = null;
        this.messageTimer = 0;
        
        this.tutorialShown = false;
        this.tutorialTimer = 0;
    }

    spawnEntities() {
        const roll = Math.random();
        
        if (roll < 0.3) {
            const types = ['log', 'buoy', 'net', 'boat', 'whirlpool', 'sleepingAnimal'];
            const type = types[Utils.randomInt(0, types.length - 1)];
            this.obstacles.push(new Obstacle(CONFIG.WIDTH + 120, type));
        } else if (roll < 0.6) {
            const types = ['small', 'large', 'moving', 'broken'];
            const weights = [0.4, 0.25, 0.2, 0.15];
            let cumulative = 0;
            let type = types[0];
            const r = Math.random();
            for (let i = 0; i < types.length; i++) {
                cumulative += weights[i];
                if (r <= cumulative) { type = types[i]; break; }
            }
            this.ramps.push(new Ramp(CONFIG.WIDTH + 120, type));
        } else {
            // Agregar vida extra ocasionalmente (10% de probabilidad)
            let types = ['fish', 'fish', 'star', 'boost'];
            if (Math.random() < 0.1) {
                types = ['life'];
            }
            const type = types[Utils.randomInt(0, types.length - 1)];
            this.collectibles.push(new Collectible(
                CONFIG.WIDTH + 80,
                CONFIG.WATER_LEVEL - Utils.random(70, 180),
                type
            ));
        }
    }

    update(dt) {
        this.input.pollGamepad();
        
        if (this.state === 'menu') {
            // En m√≥vil, la selecci√≥n se maneja en handleMenuTouch
            if (!CONFIG.IS_MOBILE) {
                if (this.input.isUpJustPressed()) {
                    this.menuSelection = (this.menuSelection - 1 + 2) % 2;
                }
                if (this.input.isDownJustPressed()) {
                    this.menuSelection = (this.menuSelection + 1) % 2;
                }
                if (this.input.isStartJustPressed()) {
                    this.selectedCharacter = this.menuSelection === 0 ? 'YACARE' : 'CARPINCHO';
                    this.reset();
                    this.state = 'playing';
                    this.tutorialTimer = 6;
                }
                if (this.input.isButton1JustPressed()) {
                    this.state = 'records';
                }
            }
            this.input.update();
            return;
        }
        
        if (this.state === 'records') {
            // En m√≥vil, el toque se maneja en handleMenuTouch
            if (!CONFIG.IS_MOBILE) {
                if (this.input.isStartJustPressed() || this.input.isButton1JustPressed()) {
                    this.state = 'menu';
                }
            }
            this.input.update();
            return;
        }
        
        if (this.state === 'enterInitials') {
            // En m√≥vil, mostrar el input nativo
            if (CONFIG.IS_MOBILE) {
                this.showMobileInitialsInput();
                this.input.update();
                return;
            }
            
            if (this.input.isUpJustPressed()) {
                this.charIndex = (this.charIndex - 1 + INITIAL_CHARS.length) % INITIAL_CHARS.length;
                this.initials[this.currentInitialIndex] = INITIAL_CHARS[this.charIndex];
            }
            if (this.input.isDownJustPressed()) {
                this.charIndex = (this.charIndex + 1) % INITIAL_CHARS.length;
                this.initials[this.currentInitialIndex] = INITIAL_CHARS[this.charIndex];
            }
            
            if (this.input.isRightJustPressed()) {
                if (this.currentInitialIndex < 2) {
                    this.currentInitialIndex++;
                    this.charIndex = INITIAL_CHARS.indexOf(this.initials[this.currentInitialIndex]);
                }
            }
            if (this.input.isLeftJustPressed()) {
                if (this.currentInitialIndex > 0) {
                    this.currentInitialIndex--;
                    this.charIndex = INITIAL_CHARS.indexOf(this.initials[this.currentInitialIndex]);
                }
            }
            
            if (this.input.isStartJustPressed()) {
                const initialsStr = this.initials.join('');
                this.recordSystem.addRecord(initialsStr, this.score, this.distance, this.selectedCharacter);
                this.state = 'records';
            }
            
            this.input.update();
            return;
        }
        
        if (this.state === 'gameover') {
            // En m√≥vil, el toque se maneja en handleMenuTouch
            if (!CONFIG.IS_MOBILE) {
                if (this.input.isStartJustPressed()) {
                    if (this.recordSystem.isHighScore(this.score)) {
                        this.state = 'enterInitials';
                        this.initials = ['A', 'A', 'A'];
                        this.currentInitialIndex = 0;
                        this.charIndex = 0;
                    } else {
                        this.state = 'menu';
                        this.menuSelection = 0;
                    }
                }
            }
            this.input.update();
            return;
        }
        
        if (this.state === 'paused') {
            if (this.input.isStartJustPressed()) {
                this.state = 'playing';
            }
            this.input.update();
            return;
        }

        this.gameTime += dt;
        
        if (this.tutorialTimer > 0) {
            this.tutorialTimer -= dt;
        }
        
        this.waterSystem.update(dt);
        
        this.scrollSpeed = this.player.vx;
        this.scrollOffset += this.scrollSpeed;
        this.distance += this.scrollSpeed * 0.1;
        
        this.difficulty = 1 + Math.floor(this.distance / 2500) * 0.12;
        
        this.timeOfDayTimer += dt;
        if (this.timeOfDayTimer > 50) {
            this.timeOfDayTimer = 0;
            const times = ['DAY', 'SUNSET', 'STORM'];
            const idx = times.indexOf(this.timeOfDay);
            this.timeOfDay = times[(idx + 1) % times.length];
        }
        
        this.spawnTimer += dt * 1000;
        if (this.spawnTimer > CONFIG.SPAWN_INTERVAL / this.difficulty) {
            this.spawnTimer = 0;
            this.spawnEntities();
        }
        
        this.player.update(this.input, this.waterSystem, this.scrollOffset, dt);
        
        const playerBounds = this.player.getBounds();
        for (const ramp of this.ramps) {
            if (ramp.active && !this.player.isAirborne) {
                const rampHeight = ramp.getRampHeight(this.player.x);
                if (rampHeight !== null && this.player.y >= rampHeight - 20) {
                    this.player.y = rampHeight - 20;
                    
                    if (this.player.x >= ramp.x + ramp.width - 30) {
                        this.player.jump(ramp.jumpMultiplier);
                        ramp.use();
                        this.score += 100;
                        this.showMessage('¬°RAMPA! +100', '#00ff00');
                    }
                }
            }
        }
        
        for (const obs of this.obstacles) {
            obs.update(this.scrollSpeed, this.gameTime);
            
            if (obs.active && !this.player.isAirborne && this.player.invincibleTimer <= 0) {
                if (this.checkCollision(playerBounds, obs.getBounds())) {
                    if (obs.type === 'whirlpool') {
                        // Remolino quita 2 vidas
                        this.lives -= 2;
                        this.showMessage('¬°REMOLINO! -2 ‚ù§Ô∏è', '#ff0000');
                        if (this.lives <= 0) {
                            this.lives = 0;
                            this.player.crash();
                        } else {
                            this.player.invincibleTimer = 3;
                            this.player.vx *= 0.3;
                            this.player.createBigSplash();
                        }
                    } else {
                        if (this.player.hitObstacle()) {
                            this.lives--;
                            this.score = Math.max(0, this.score - 200);
                            if (this.lives <= 0) {
                                this.lives = 0;
                                this.showMessage('¬°SIN VIDAS!', '#ff0000');
                                this.player.crash();
                            } else {
                                this.showMessage(`¬°GOLPE! -1 ‚ù§Ô∏è (${this.lives} restantes)`, '#ff6600');
                            }
                        }
                    }
                }
            }
        }
        
        for (const ramp of this.ramps) {
            ramp.update(this.scrollSpeed, this.gameTime);
        }
        
        for (const col of this.collectibles) {
            col.update(this.scrollSpeed, this.gameTime);
            
            if (col.active && !col.collected && col.checkCollision(playerBounds)) {
                const result = col.collect();
                this.score += result.value;
                if (result.effect === 'speed') {
                    this.player.boostTimer = 3.5;
                    this.showMessage('¬°TURBO!', '#00ff00');
                } else if (result.effect === 'life') {
                    if (this.lives < CONFIG.MAX_LIVES) {
                        this.lives++;
                        this.showMessage('¬°+1 VIDA! ‚ù§Ô∏è', '#ff4444');
                    } else {
                        this.score += 500;
                        this.showMessage('¬°VIDA LLENA! +500', '#ff4444');
                    }
                } else if (result.value > 0) {
                    this.showMessage(`+${result.value}`, '#ffd700');
                }
            }
        }
        
        this.obstacles = this.obstacles.filter(o => o.active);
        this.ramps = this.ramps.filter(r => r.active);
        this.collectibles = this.collectibles.filter(c => c.active);
        
        if (this.messageTimer > 0) {
            this.messageTimer -= dt;
            if (this.messageTimer <= 0) this.message = null;
        }
        
        this.score += this.scrollSpeed * 0.1;
        
        if (this.player.crashed) {
            setTimeout(() => {
                if (this.state === 'playing') this.state = 'gameover';
            }, 1800);
        }
        
        this.input.update();
    }

    checkCollision(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }

    showMessage(text, color) {
        this.message = { text, color };
        this.messageTimer = 1.8;
    }

    drawSky(ctx) {
        const colors = TIME_OF_DAY[this.timeOfDay];
        const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.WATER_LEVEL);
        gradient.addColorStop(0, colors.skyTop);
        gradient.addColorStop(1, colors.skyBottom);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.WATER_LEVEL);

        ctx.fillStyle = colors.sunColor;
        ctx.beginPath();
        const sunY = this.timeOfDay === 'SUNSET' ? 130 : (this.timeOfDay === 'STORM' ? 50 : 80);
        const sunX = CONFIG.WIDTH - 120 + Math.sin(this.gameTime * 0.1) * 10;
        ctx.arc(sunX, sunY, this.timeOfDay === 'STORM' ? 30 : 50, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.timeOfDay !== 'STORM') {
            ctx.strokeStyle = colors.sunColor + '44';
            ctx.lineWidth = 3;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + this.gameTime * 0.2;
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * 55, sunY + Math.sin(angle) * 55);
                ctx.lineTo(sunX + Math.cos(angle) * 75, sunY + Math.sin(angle) * 75);
                ctx.stroke();
            }
        }

        ctx.fillStyle = colors.cloudColor;
        this.drawCloud(ctx, ((150 - this.gameTime * 8) % 1200) - 100, 80, 1.2);
        this.drawCloud(ctx, ((500 - this.gameTime * 12) % 1200) - 100, 55, 1);
        this.drawCloud(ctx, ((800 - this.gameTime * 10) % 1200) - 100, 95, 1.4);
    }

    drawCloud(ctx, x, y, scale) {
        ctx.beginPath();
        ctx.arc(x, y, 25 * scale, 0, Math.PI * 2);
        ctx.arc(x + 30 * scale, y - 15 * scale, 32 * scale, 0, Math.PI * 2);
        ctx.arc(x + 60 * scale, y, 25 * scale, 0, Math.PI * 2);
        ctx.arc(x + 30 * scale, y + 10 * scale, 20 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    drawHUD(ctx) {
        const p = 15;
        const rightX = CONFIG.WIDTH - 240; // Posici√≥n X para el lado derecho
        
        // Panel principal del HUD (lado derecho)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(rightX - 5, p - 10, 235, 140);
        ctx.strokeStyle = '#4a6a8a';
        ctx.lineWidth = 2;
        ctx.strokeRect(rightX - 5, p - 10, 235, 140);
        
        ctx.font = 'bold 15px Courier New';
        
        // Vidas con corazones
        ctx.fillStyle = '#ff4444';
        let heartsText = '';
        for (let i = 0; i < CONFIG.MAX_LIVES; i++) {
            if (i < this.lives) {
                heartsText += '‚ù§Ô∏è ';
            } else {
                heartsText += 'üñ§ ';
            }
        }
        ctx.fillText(heartsText, rightX, p + 14);
        
        ctx.fillStyle = '#ffd700';
        ctx.fillText(`‚≠ê PUNTAJE: ${Math.floor(this.score)}`, rightX, p + 38);
        
        ctx.fillStyle = '#0f0';
        ctx.fillText(`üìç DISTANCIA: ${Math.floor(this.distance)}m`, rightX, p + 62);
        
        ctx.fillStyle = '#0bf';
        ctx.fillText(`üöÄ VELOCIDAD:`, rightX, p + 86);
        
        ctx.fillStyle = '#222';
        ctx.fillRect(rightX + 115, p + 74, 95, 16);
        const speedPercent = Math.floor((this.player.vx / CONFIG.MAX_SPEED) * 100);
        const speedColor = speedPercent > 85 ? '#f44' : speedPercent > 55 ? '#fa0' : '#0f0';
        ctx.fillStyle = speedColor;
        ctx.fillRect(rightX + 115, p + 74, speedPercent * 0.95, 16);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(rightX + 115, p + 74, 95, 16);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px Courier New';
        ctx.fillText(`${speedPercent}%`, rightX + 150, p + 87);
        
        ctx.fillStyle = this.player.stats.color;
        ctx.fillRect(rightX, p + 102, 16, 16);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Courier New';
        ctx.fillText(this.player.stats.name.toUpperCase(), rightX + 22, p + 115);
        
        // Record en la esquina izquierda
        const records = this.recordSystem.getRecords();
        if (records.length > 0) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(p - 10, p - 10, 170, 40);
            ctx.strokeStyle = '#ffd700';
            ctx.strokeRect(p - 10, p - 10, 170, 40);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 12px Courier New';
            ctx.fillText(`üèÜ RECORD: ${records[0].score}`, p, p + 10);
            ctx.fillStyle = '#aaa';
            ctx.font = '10px Courier New';
            ctx.fillText(`${records[0].initials}`, p, p + 24);
        }
    }

    drawTutorial(ctx) {
        if (this.tutorialTimer <= 0) return;
        
        const alpha = Math.min(1, this.tutorialTimer * 0.5);
        ctx.globalAlpha = alpha;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(CONFIG.WIDTH / 2 - 240, 120, 480, 250);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.strokeRect(CONFIG.WIDTH / 2 - 240, 120, 480, 250);
        
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 22px Courier New';
        
        if (CONFIG.IS_MOBILE) {
            // Tutorial para m√≥vil
            ctx.fillText('üì± ¬°MODO M√ìVIL!', CONFIG.WIDTH / 2, 170);
            
            ctx.fillStyle = '#fff';
            ctx.font = '18px Courier New';
            ctx.fillText('üöÄ ACELERACI√ìN AUTOM√ÅTICA', CONFIG.WIDTH / 2, 210);
            ctx.fillText('üëÜ TOCA LA PANTALLA = SALTAR', CONFIG.WIDTH / 2, 250);
            
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 16px Courier New';
            ctx.fillText('¬°USA LAS RAMPAS PARA SALTAR!', CONFIG.WIDTH / 2, 295);
            
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('La inclinaci√≥n se ajusta autom√°ticamente', CONFIG.WIDTH / 2, 330);
            ctx.fillText('¬°Evita los obst√°culos y recoge bonus!', CONFIG.WIDTH / 2, 355);
        } else {
            // Tutorial normal
            ctx.fillText('¬°CONTROLES!', CONFIG.WIDTH / 2, 170);
            
            ctx.fillStyle = '#fff';
            ctx.font = '16px Courier New';
            ctx.fillText('üéÆ A / Bot√≥n 1 / ‚Üí  =  ACELERAR', CONFIG.WIDTH / 2, 200);
            ctx.fillText('üõë ‚Üê / Palanca Izq  =  FRENAR', CONFIG.WIDTH / 2, 228);
            ctx.fillText('ü¶ò S / Bot√≥n 2  =  SALTAR', CONFIG.WIDTH / 2, 256);
            ctx.fillText('üîÑ D / Bot√≥n 3  =  INICIAR/REINICIAR', CONFIG.WIDTH / 2, 284);
            ctx.fillText('‚¨Ü‚¨á Arriba/Abajo  =  INCLINAR EN AIRE', CONFIG.WIDTH / 2, 312);
            
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('¬°Aterriza nivelado para no chocar!', CONFIG.WIDTH / 2, 342);
        }
        
        ctx.textAlign = 'left';
        ctx.globalAlpha = 1;
    }

    drawMenu(ctx) {
        this.drawSky(ctx);
        this.background.draw(ctx, this.scrollOffset, 'DAY', this.gameTime);
        this.waterSystem.draw(ctx, 'DAY', this.scrollOffset);
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 48px Courier New';
        ctx.fillText('R√çO SALVAJE', CONFIG.WIDTH / 2, 85);
        
        ctx.fillStyle = '#00bcd4';
        ctx.font = '18px Courier New';
        ctx.fillText('Carreras en el Litoral Argentino', CONFIG.WIDTH / 2, 118);
        
        ctx.fillStyle = '#e74c3c';
        ctx.font = '20px Arial';
        ctx.fillText('üå∫ Jacarand√°s ‚Ä¢ Ceibos ‚Ä¢ Estrellas Federales üå∫', CONFIG.WIDTH / 2, 150);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Courier New';
        ctx.fillText('ELIGE TU CORREDOR', CONFIG.WIDTH / 2, 195);
        
        const y1 = 255;
        // En m√≥vil, ambas casillas se muestran siempre activas para indicar que son t√°ctiles
        const yacareBorder = CONFIG.IS_MOBILE ? '#ffd700' : (this.menuSelection === 0 ? '#ffd700' : '#444');
        ctx.strokeStyle = yacareBorder;
        ctx.lineWidth = 4;
        ctx.strokeRect(CONFIG.WIDTH / 2 - 260, y1 - 40, 520, 80);
        if (this.menuSelection === 0 || CONFIG.IS_MOBILE) {
            ctx.fillStyle = CONFIG.IS_MOBILE ? 'rgba(46, 200, 64, 0.2)' : 'rgba(255, 215, 0, 0.15)';
            ctx.fillRect(CONFIG.WIDTH / 2 - 260, y1 - 40, 520, 80);
        }
        
        ctx.fillStyle = (this.menuSelection === 0 || CONFIG.IS_MOBILE) ? '#ffd700' : '#888';
        ctx.font = 'bold 24px Courier New';
        ctx.fillText('üêä  YACAR√â', CONFIG.WIDTH / 2, y1 - 5);
        ctx.fillStyle = (this.menuSelection === 0 || CONFIG.IS_MOBILE) ? '#bbb' : '#555';
        ctx.font = '14px Courier New';
        ctx.fillText('Lancha - Pesado y Estable', CONFIG.WIDTH / 2, y1 + 22);
        
        // Indicador t√°ctil en m√≥vil
        if (CONFIG.IS_MOBILE) {
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 12px Courier New';
            ctx.fillText('üëÜ TOCA AQU√ç', CONFIG.WIDTH / 2 + 180, y1);
        }
        
        const y2 = 360;
        const carpinchoBorder = CONFIG.IS_MOBILE ? '#ffd700' : (this.menuSelection === 1 ? '#ffd700' : '#444');
        ctx.strokeStyle = carpinchoBorder;
        ctx.strokeRect(CONFIG.WIDTH / 2 - 260, y2 - 40, 520, 80);
        if (this.menuSelection === 1 || CONFIG.IS_MOBILE) {
            ctx.fillStyle = CONFIG.IS_MOBILE ? 'rgba(255, 180, 50, 0.2)' : 'rgba(255, 215, 0, 0.15)';
            ctx.fillRect(CONFIG.WIDTH / 2 - 260, y2 - 40, 520, 80);
        }
        
        ctx.fillStyle = (this.menuSelection === 1 || CONFIG.IS_MOBILE) ? '#ffd700' : '#888';
        ctx.font = 'bold 24px Courier New';
        ctx.fillText('ü¶´  CARPINCHO', CONFIG.WIDTH / 2, y2 - 5);
        ctx.fillStyle = (this.menuSelection === 1 || CONFIG.IS_MOBILE) ? '#bbb' : '#555';
        ctx.font = '14px Courier New';
        ctx.fillText('Moto de Agua - R√°pido y √Ågil', CONFIG.WIDTH / 2, y2 + 22);
        
        // Indicador t√°ctil en m√≥vil
        if (CONFIG.IS_MOBILE) {
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 12px Courier New';
            ctx.fillText('üëÜ TOCA AQU√ç', CONFIG.WIDTH / 2 + 180, y2);
        }
        
        const blink = Math.floor(Date.now() / 350) % 2;
        ctx.fillStyle = '#0f0';
        ctx.font = 'bold 16px Courier New';
        if (blink) {
            if (CONFIG.IS_MOBILE) {
                ctx.fillText('üëÜ TOCA UN PERSONAJE PARA JUGAR üëÜ', CONFIG.WIDTH / 2, 460);
            } else {
                ctx.fillText('‚ñ∂ D / BOT√ìN 3 = JUGAR ‚óÄ', CONFIG.WIDTH / 2, 460);
            }
        }
        
        ctx.fillStyle = '#888';
        ctx.font = '12px Courier New';
        if (CONFIG.IS_MOBILE) {
            ctx.fillText('üì± MODO M√ìVIL ACTIVADO', CONFIG.WIDTH / 2, 485);
            ctx.fillText('Toca el YACAR√â o CARPINCHO para elegir y jugar', CONFIG.WIDTH / 2, 505);
        } else {
            ctx.fillText('‚Üë‚Üì o Palanca para seleccionar', CONFIG.WIDTH / 2, 485);
            ctx.fillText('A / BOT√ìN 1 = VER RECORDS', CONFIG.WIDTH / 2, 505);
        }
        
        ctx.textAlign = 'left';
    }

    drawRecords(ctx) {
        ctx.fillStyle = 'rgba(0, 0, 20, 0.95)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        
        ctx.textAlign = 'center';
        
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 36px Courier New';
        ctx.fillText('üèÜ MEJORES PUNTAJES üèÜ', CONFIG.WIDTH / 2, 60);
        
        const records = this.recordSystem.getRecords();
        
        if (records.length === 0) {
            ctx.fillStyle = '#888';
            ctx.font = '20px Courier New';
            ctx.fillText('No hay records todav√≠a', CONFIG.WIDTH / 2, 280);
            ctx.fillText('¬°S√© el primero en jugar!', CONFIG.WIDTH / 2, 310);
        } else {
            ctx.fillStyle = '#0bf';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('POS    INICIALES    PUNTAJE    DISTANCIA    PERSONAJE    FECHA', CONFIG.WIDTH / 2, 110);
            
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(150, 120);
            ctx.lineTo(CONFIG.WIDTH - 150, 120);
            ctx.stroke();
            
            for (let i = 0; i < records.length; i++) {
                const r = records[i];
                const y = 155 + i * 35;
                
                if (i === 0) ctx.fillStyle = '#ffd700';
                else if (i === 1) ctx.fillStyle = '#c0c0c0';
                else if (i === 2) ctx.fillStyle = '#cd7f32';
                else ctx.fillStyle = '#888';
                
                ctx.font = 'bold 16px Courier New';
                const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
                
                const charIcon = r.character === 'YACARE' ? 'üêä' : 'ü¶´';
                
                ctx.fillText(
                    `${medal}    ${r.initials}        ${r.score.toString().padStart(6, ' ')}       ${r.distance}m        ${charIcon}        ${r.date}`,
                    CONFIG.WIDTH / 2, y
                );
            }
        }
        
        const blink = Math.floor(Date.now() / 400) % 2;
        ctx.fillStyle = '#0f0';
        ctx.font = 'bold 16px Courier New';
        if (blink) {
            if (CONFIG.IS_MOBILE) {
                ctx.fillText('üëÜ TOCA PARA VOLVER AL MEN√ö', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 40);
            } else {
                ctx.fillText('D / BOT√ìN 3 = VOLVER AL MEN√ö', CONFIG.WIDTH / 2, CONFIG.HEIGHT - 40);
            }
        }
        
        ctx.textAlign = 'left';
    }

    drawEnterInitials(ctx) {
        ctx.fillStyle = 'rgba(0, 0, 30, 0.95)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        
        ctx.textAlign = 'center';
        
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 32px Courier New';
        ctx.fillText('¬°NUEVO RECORD!', CONFIG.WIDTH / 2, 80);
        
        ctx.fillStyle = '#fff';
        ctx.font = '20px Courier New';
        ctx.fillText(`PUNTAJE: ${Math.floor(this.score)}`, CONFIG.WIDTH / 2, 130);
        ctx.fillText(`DISTANCIA: ${Math.floor(this.distance)}m`, CONFIG.WIDTH / 2, 160);
        
        ctx.fillStyle = '#0bf';
        ctx.font = 'bold 24px Courier New';
        ctx.fillText('INGRESA TUS INICIALES', CONFIG.WIDTH / 2, 220);
        
        const boxWidth = 80;
        const boxHeight = 100;
        const spacing = 20;
        const startX = CONFIG.WIDTH / 2 - (boxWidth * 1.5 + spacing);
        
        for (let i = 0; i < 3; i++) {
            const x = startX + i * (boxWidth + spacing);
            const y = 260;
            
            ctx.strokeStyle = i === this.currentInitialIndex ? '#ffd700' : '#444';
            ctx.lineWidth = i === this.currentInitialIndex ? 4 : 2;
            ctx.strokeRect(x, y, boxWidth, boxHeight);
            
            if (i === this.currentInitialIndex) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.fillRect(x, y, boxWidth, boxHeight);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('‚ñ≤', x + boxWidth / 2, y - 10);
                ctx.fillText('‚ñº', x + boxWidth / 2, y + boxHeight + 30);
            }
            
            ctx.fillStyle = i === this.currentInitialIndex ? '#ffd700' : '#fff';
            ctx.font = 'bold 48px Courier New';
            const char = this.initials[i] === ' ' ? '‚ê£' : this.initials[i];
            ctx.fillText(char, x + boxWidth / 2, y + boxHeight / 2 + 18);
        }
        
        ctx.fillStyle = '#888';
        ctx.font = '14px Courier New';
        ctx.fillText('‚Üë‚Üì o Palanca = Cambiar letra', CONFIG.WIDTH / 2, 430);
        ctx.fillText('‚Üê‚Üí = Mover posici√≥n', CONFIG.WIDTH / 2, 455);
        
        const blink = Math.floor(Date.now() / 400) % 2;
        ctx.fillStyle = '#0f0';
        ctx.font = 'bold 18px Courier New';
        if (blink) {
            ctx.fillText('D / BOT√ìN 3 = CONFIRMAR', CONFIG.WIDTH / 2, 500);
        }
        
        ctx.textAlign = 'left';
    }

    drawGameOver(ctx) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        
        ctx.textAlign = 'center';
        
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 48px Courier New';
        ctx.fillText('¬°FIN DEL JUEGO!', CONFIG.WIDTH / 2, 120);
        
        // Mostrar corazones vac√≠os
        ctx.font = '36px Arial';
        ctx.fillText('üñ§ üñ§ üñ§ üñ§ üñ§', CONFIG.WIDTH / 2, 170);
        
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 28px Courier New';
        ctx.fillText(`PUNTAJE FINAL: ${Math.floor(this.score)}`, CONFIG.WIDTH / 2, 230);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 22px Courier New';
        ctx.fillText(`DISTANCIA: ${Math.floor(this.distance)} metros`, CONFIG.WIDTH / 2, 280);
        
        if (this.recordSystem.isHighScore(this.score)) {
            ctx.fillStyle = '#ff0';
            ctx.font = 'bold 24px Courier New';
            const blink = Math.floor(Date.now() / 300) % 2;
            if (blink) {
                ctx.fillText('‚òÖ ¬°NUEVO RECORD! ‚òÖ', CONFIG.WIDTH / 2, 340);
            }
        }
        
        // Bot√≥n t√°ctil visual para m√≥vil
        if (CONFIG.IS_MOBILE) {
            ctx.fillStyle = 'rgba(0, 200, 100, 0.3)';
            ctx.fillRect(CONFIG.WIDTH / 2 - 180, 380, 360, 60);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 3;
            ctx.strokeRect(CONFIG.WIDTH / 2 - 180, 380, 360, 60);
        }
        
        ctx.fillStyle = '#00bcd4';
        ctx.font = 'bold 18px Courier New';
        const blink = Math.floor(Date.now() / 350) % 2;
        if (blink) {
            if (CONFIG.IS_MOBILE) {
                ctx.fillText('üëÜ TOCA AQU√ç PARA CONTINUAR', CONFIG.WIDTH / 2, 418);
            } else {
                ctx.fillText('D / BOT√ìN 3 = CONTINUAR', CONFIG.WIDTH / 2, 420);
            }
        }
        
        ctx.textAlign = 'left';
    }

    drawPaused(ctx) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 52px Courier New';
        ctx.fillText('‚è∏ PAUSA', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 - 20);
        
        ctx.font = '20px Courier New';
        ctx.fillText('D / Bot√≥n 3 para continuar', CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2 + 40);
        ctx.textAlign = 'left';
    }

    render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
        
        if (this.state === 'menu') {
            this.scrollOffset += 1;
            this.gameTime += 0.016;
            this.waterSystem.update(0.016);
            this.drawMenu(ctx);
            return;
        }
        
        if (this.state === 'records') {
            this.drawRecords(ctx);
            return;
        }
        
        if (this.state === 'enterInitials') {
            this.drawEnterInitials(ctx);
            return;
        }
        
        this.drawSky(ctx);
        this.background.draw(ctx, this.scrollOffset, this.timeOfDay, this.gameTime);
        this.waterSystem.draw(ctx, this.timeOfDay, this.scrollOffset);
        
        for (const ramp of this.ramps) {
            ramp.draw(ctx);
        }
        
        for (const col of this.collectibles) {
            col.draw(ctx, this.gameTime);
        }
        
        for (const obs of this.obstacles) {
            obs.draw(ctx, this.gameTime);
        }
        
        this.player.draw(ctx);
        
        this.drawHUD(ctx);
        this.drawTutorial(ctx);
        
        if (this.message) {
            ctx.textAlign = 'center';
            ctx.font = 'bold 32px Courier New';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.strokeText(this.message.text, CONFIG.WIDTH / 2, 240);
            ctx.fillStyle = this.message.color;
            ctx.fillText(this.message.text, CONFIG.WIDTH / 2, 240);
            ctx.textAlign = 'left';
        }
        
        if (this.state === 'gameover') {
            this.drawGameOver(ctx);
        } else if (this.state === 'paused') {
            this.drawPaused(ctx);
        }
    }

    gameLoop(currentTime) {
        const dt = Math.min((currentTime - this.lastTime) / 1000, 0.05);
        this.lastTime = currentTime;
        
        this.update(dt);
        this.render();
        
        requestAnimationFrame((t) => this.gameLoop(t));
    }

    start() {
        this.gameLoop(performance.now());
        
        // Configurar input m√≥vil para iniciales
        if (CONFIG.IS_MOBILE) {
            this.setupMobileInitialsInput();
        }
    }
    
    setupMobileInitialsInput() {
        const container = document.getElementById('mobileInitialsContainer');
        const input = document.getElementById('mobileInitialsInput');
        const confirmBtn = document.getElementById('confirmInitialsBtn');
        
        confirmBtn.addEventListener('click', () => {
            this.confirmMobileInitials();
        });
        
        confirmBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.confirmMobileInitials();
        });
        
        input.addEventListener('input', (e) => {
            // Forzar may√∫sculas y limitar a 3 caracteres
            e.target.value = e.target.value.toUpperCase().slice(0, 3);
        });
        
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.confirmMobileInitials();
            }
        });
    }
    
    showMobileInitialsInput() {
        const container = document.getElementById('mobileInitialsContainer');
        const input = document.getElementById('mobileInitialsInput');
        
        if (container.style.display !== 'block') {
            container.style.display = 'block';
            input.value = '';
            input.focus();
        }
    }
    
    hideMobileInitialsInput() {
        const container = document.getElementById('mobileInitialsContainer');
        container.style.display = 'none';
    }
    
    confirmMobileInitials() {
        const input = document.getElementById('mobileInitialsInput');
        let initials = input.value.toUpperCase().trim();
        
        // Rellenar con A si faltan caracteres
        while (initials.length < 3) {
            initials += 'A';
        }
        
        initials = initials.slice(0, 3);
        
        this.recordSystem.addRecord(initials, this.score, this.distance, this.selectedCharacter);
        this.hideMobileInitialsInput();
        this.state = 'records';
    }
}

// =============================================================================
// INICIAR JUEGO
// =============================================================================
window.addEventListener('load', () => {
    const game = new Game();
    game.start();
});
</script>
</body>
</html>
